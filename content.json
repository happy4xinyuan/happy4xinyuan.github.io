{"pages":[],"posts":[{"title":"Beginning of Everything 起点","text":"“hust&gt; rm -rf”, 了结过往, 面向未来, 是我为HUST计算机学院设计的毕业衫图案 2020年, 没有想象中美好的毕业仪式, 大学四年生活匆匆收场. 本以为最最美好的”大学四年级”结果却是如此孤独寂寥, 假如不是这场疫情所致, 也许现在我已经做好了去美国留学的打算. 在家颓靡的这几个月, 美其名曰”韬光养晦”, 其实也只是浑浑噩噩. 现已是7月底, 大家纷纷找了实习, 而我却迟迟没有迈出这一步. 既然人生这么多遗憾, 为什么不记录下那些美好的时刻呢? 于是乎, 我建立起这个博客, 意在记录那些学习技术过程中的快乐时光. 正如我博客的slogan所言 “have fun with tech“ , 学习技术的过程本身就是一种快乐, 正如男孩学会了积木的拼接, 进而用乐高创造出属于自己的快乐世界. 我也希望在学习的过程中, 记录这些创造性的快乐时刻, 与你们分享技术的乐趣. Go! Go! Xinyuan, explore the Tech &amp; have Fun ! :sparkling_heart:","link":"/2020/07/28/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"},{"title":"react-组件化开发","text":"1.1. 基本理解和使用1234567891011121314151617181). 自定义的标签: 组件类(函数)/标签2). 创建组件类 //方式1: 无状态函数(简单组件, 推荐使用) function MyComponent1(props) { return &lt;h1&gt;自定义组件标题11111&lt;/h1&gt; } //方式2: ES6类语法(复杂组件, 推荐使用) class MyComponent3 extends React.Component { render () { return &lt;h1&gt;自定义组件标题33333&lt;/h1&gt; } }3). 渲染组件标签 ReactDOM.render(&lt;MyComp /&gt;, cotainerEle)4). ReactDOM.render()渲染组件标签的基本流程 React内部会创建组件实例对象/调用组件函数, 得到虚拟DOM对象 将虚拟DOM并解析为真实DOM 插入到指定的页面元素内部 2.1. 组件的3大属性: state123456789101112131. 组件被称为\"状态机\", 页面的显示是根据组件的state属性的数据来显示2. 初始化指定: constructor() { super() this.state = { stateName1 : stateValue1, stateName2 : stateValue2 } }3. 读取显示: this.state.stateName14. 更新状态--&gt;更新界面 : this.setState({stateName1 : newValue}) 2.2. 组件的3大属性: props1234567891011所有组件标签的属性的集合对象给标签指定属性, 保存外部数据(可能是一个function)在组件内部读取属性: this.props.propertyName作用: 从目标组件外部向组件内部传递数据对props中的属性值进行类型限制和必要性限制 Person.propTypes = { name: React.PropTypes.string.isRequired, age: React.PropTypes.number.isRequired }扩展属性: 将对象的所有属性通过props传递 &lt;Person {...person}/&gt; 2.3. 组件的3大属性: refs组件内包含ref属性的标签元素的集合对象 给操作目标标签指定ref属性, 打一个标识 在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象) 作用: 找到组件内部的真实dom元素对象, 进而操作它面试题问题: 请区别一下组件的 props 和 state 属性? 1) state: 组件自身内部可变化的数据 2) props: 从组件外部向组件内部传递数据, 组件内部只读不修 3.3. 组件的组合设计思路 1) 拆分组件: 拆分界面,抽取组件 2) 实现静态组件: 使用组件实现静态页面效果 3) 实现动态组件 a. 动态显示初始化数据 b. 交互功能(从绑定事件监听开始 思考问题: 数据保存在那个组件中? 两个子组件, 一个读, 一个写. 故放在父组件中. 1234567891011121314//li显示常用技巧: class TodoList extends React.Component { render () { const {todos} = this.props return ( &lt;ul&gt; { //map函数!!! todos.map((todo, index) =&gt; &lt;li key={index}&gt;{todo}&lt;/li&gt;) } &lt;/ul&gt; ) } } 4. 实例实现效果: html 内容: 导入库, 设置容器 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05_components_composing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; //导入所需react库, 与babel库 &lt;script type=\"text/javascript\" src=\"../js/react.development.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/react-dom.development.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/prop-types.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/babel.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/babel\"&gt; ... &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件设计思路:具体实现: 123456789101112131415161718192021222324252627282930313233343536/*1)拆分组件: 拆分界面,抽取组件2)实现静态组件: 使用组件实现静态页面效果3)实现动态组件 ① 动态显示初始化数据 ② 交互功能(从绑定事件监听开始) */// 应用组件[state]class App extends React.Component { constructor (props) { super(props) // 初始化状态 this.state = { todos: ['吃饭', '睡觉', '打豆豆'] } this.add = this.add.bind(this) } add (todo) { const {todos} = this.state todos.unshift(todo) //更新状态 必须使用set State( 修改之后的完整state ) this.setState({todos}) } render () { const {todos} = this.state return ( //只能有一个根标签, 所以用div包括 &lt;div&gt; // 必须制定this.add, 否则只会在render的域搜索 &lt;TodoAdd add={this.add} count={todos.length} /&gt; //此处将APP的state中的todos内容, 传给TodoList的props中的todos属性 &lt;TodoList todos={todos} /&gt; &lt;/div&gt; ) }} 123456789101112131415161718192021222324252627282930313233343536373839 // 添加todo组件 [props,ref] class TodoAdd extends React.Component { //固定套路,记得写上 constructor (props) { super(props) this.addTodo = this.addTodo.bind(this) } // addTodo () { // 读取输入数据 const text = this.input.value.trim() // 查检 if(!text) { return } // 保存到todos this.props.add(text) // 清除输入 this.input.value = '' } render () { return ( &lt;div&gt; &lt;h2&gt;Simple TODO List&lt;/h2&gt; //利用ref属性完成外部输入的数据流入到本组件的属性内 //其中ref={input =&gt; this.sinput=input} sinput为定义给TodoAdd组件的属性,可以自己修改. //可以在其他地方通过this.sinput指示该输入框元素,利用this.sinput.value获取填入值 &lt;input type=&quot;text&quot; ref={input =&gt; this.input=input}/&gt;//对应失去焦点的函数为onBlur &lt;button onClick={this.addTodo}&gt;Add #{this.props.count}&lt;/button&gt; &lt;/div&gt; ) } } //由App组件传入的数据, 可以通过this.props.add直接调用 TodoAdd.propTypes = { add: PropTypes.func.isRequired, count: PropTypes.number.isRequired } 12345678910111213141516171819// todo列表组件 [props组件]class TodoList extends React.Component { render () { // 什么意思? props是一个对象,todo就是取出了这个对象的内容,即array const {todos} = this.props return ( &lt;ul&gt; {// 对arry执行map, 其中设置key为index是默认操作 //一行的箭头函数包含了return操作 todos.map((todo, index) =&gt; &lt;li key={index}&gt;{todo}&lt;/li&gt;) } &lt;/ul&gt; ) }}//增加属性, 实际是增加到props下. 相当于增加接受数据的入口.TodoList.propTypes = { todos: PropTypes.array.isRequired} 12// 渲染应用组件标签ReactDOM.render(&lt;App /&gt;, document.getElementById('example'))","link":"/2020/08/21/react%20%E7%BB%84%E4%BB%B6/"},{"title":"面试-css","text":"box模型, link标签和import标签的区别, Flex布局, 浮动清除, css3新特性 box模型标准box模型 IE盒子模型：区别是width 把border也包括了 模型选择: CSS3中引入了box-sizing属性. box-sizing:content-box -&gt; 表示标准的盒子模型 box-sizing:border-box -&gt; IE盒子模型 link标签和import标签的区别 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"\"&gt; link属于html标签，页面被加载时，link会同时被加载. @import是css提供的, @import引用的css会等到页面加载结束后加载。 link是html标签都能用，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的。 Flex布局Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。布局的传统解决方案，基于盒状模型，依赖display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 ? 我一般使用boostrap row col-md-6这样 垂直居中4)利用flex 将父元素设置为display:flex，并且设置align-items:center;justify-content:center; 12345678910111213141516css:.container{ width: 300px; height: 200px; border: 3px solid #546461; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center;}.inner{ border: 3px solid #458761; padding: 20px;} 块级元素和行内元素块级元素 block：p div 独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度 行内元素 inline：span 不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。 转换: a. display:none;不显示该元素，也不会保留该元素原先占有的文档流位置。 b. display:block;转换为块级元素。 c. display:inline;转换为行内元素。 d. display:inline-block;转换为行内块级元素。 visibility=hidden, opacity=0，display:noneopacity=0，该元素隐藏，不会改变页面布局，绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的 visibility=hidden，该元素隐藏起来了，不会改变页面布局，但是不会触发该元素已经绑定的事件 display=none，把元素隐藏起来，改变页面布局，可以理解成在页面中把该元素删除掉一样。 position属性 比较固定定位fixed： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。(如navbar 相对定位relative： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位absolute： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。 粘性定位sticky： 元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。 默认定位Static： 默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。 inherit: 规定应该从父元素继承position 属性的值。 浮动清除? 没听说过. 参考https://www.cnblogs.com/ForEvErNoME/p/3383539.html 方法一：使用带clear属性的空元素 在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;来进行清理。 方法二：使用CSS的overflow属性 给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。 在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 css3新特性 CSS3边框： border-radius边角，box-shadow CSS3背景：background-size： CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片 CSS3文字效果：text-shadow. word-wrap :单词太长的话就可能无法超出某个区域，允许对长单词进行拆分，并换行到下一行：p{word-wrap:break-word;} CSS3 2D转换, 3D转换, 动画","link":"/2020/08/18/%E9%9D%A2%E8%AF%95-CSS/"},{"title":"个人简历","text":"核心专业课成绩 算法分析与设计(97) 计算机通信与网络(92) 数据库系统原理(97) 操作系统原理(89)","link":"/2020/08/18/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"},{"title":"面试-网络知识","text":"http, http2.0, TCP, UDP, url过程.. http &amp; httpshttp和https的基本概念http: 超文本传输协议 HyperText Transfer Protocol是一个客户端和服务器端请求和应答的标准（TCP）, 用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 明文的. 是无状态的 https: 超文本传输安全协议 HyperText Transfer Protocol Secure是以安全为目标的HTTP通道，即HTTP + SSL https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。 具有安全性的ssl加密传输协议 一般而言，http协议的端口为80，https的端口为443 身份认证 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 https缺点: https握手阶段比较费时，https缓存不如http高效，会增加数据开销。SSL证书也需要钱，功能越强大的证书费用越高。SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。 报文HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文 状态码: 200 OK 客户端请求成功 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。前端提交数据的字段名称和字段类型与后台的实体没有保持一致. json字符串类型 结果给的Obj 304 Not Modified 文件未修改，可以直接使用缓存的文件。如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。 200与304的区别: 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 http版本问题http2.0 : 内容安全，应为http2.0是基于https的 提升访问速度, 允许多路复用(改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。) 首部压缩 二进制格式: http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码(有更多的扩展性) TCP &amp; UDP TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。 TCP提供可靠的服务。无差错，不丢失，不重复，且按序到达. 适合大数据量的交换。 UDP尽最大努力交付，即不保证可靠交付。适合视频? TCP只能是1对1的，UDP支持1对1,1对多。 TCP的首部较大为20字节，而UDP只有8字节。 web sockethttp协议不支持持久性连接。WebSocket是HTML5中的协议，支持持久连续. Http1.0和HTTP1.1都不支持持久性的链接，(HTTP1.1中的keep-alive，将多个http请求合并为1个) HTTP的生命周期通过Request来界定，也就是Request一个Response，那么在Http1.0协议中，这次Http请求就结束了。 在Http1.1中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个Http连接中，可以发送多个Request，接收多个Response。 WebSocket是什么样的协议，具体有什么优点？WebSocket是基于Http协议的, 在握手阶段与Http是相同的。 Cookie、sessionStorage、localStorage的区别共同点：保存在浏览器端，并且是同源的 Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。用来保存用户登录状态(设置过期时间)。跟踪用户行为。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 有效期区别: sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持 localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据 cookie: 只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 作用域区别: sessionStorage：不同的浏览器窗口中不能共享； localStorage：在所有同源窗口都是共享的； cookie：也是在所有同源窗口中共享的 Cookie如何防范XSS攻击XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie： httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。 secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。 自己做的时候就是, sanitize npm库 HTML5新增 更好的实践web语义化，增加了header，footer，nav,aside,section等语义化标签， 在表单方面，为了增强表单，为input增加了color，emial,data ,range等类型 在存储方面，提供了sessionStorage，localStorage,和离线存储 在多媒体方面, 规定了音频和视频元素audio和vedio canvas绘图，支持内联SVG。支持MathML 多线程编程的web worker和websocket协议 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？输入url -&gt; 需要找到这个url域名的服务器ip -&gt; { 查看缓存中是否有记录 -&gt;缓存的查找记录为：`浏览器缓存-&gt;系统缓存-&gt;路由器缓存 缓存中没有 -&gt; hosts文件 还没有 -&gt; 查询DNS服务器 -&gt; 得到服务器的ip地址 } 网络通信阶段: {浏览器根据ip&amp;端口号，构造一个http请求 -&gt; 封装在一个tcp包中 建立TCP链接: tcp包 -&gt; 依次经过传输层，网络层，数据链路层，物理层到达服务器 服务器解析该请求 -&gt; 返回相应的html给浏览器} 构建网页阶段: 浏览器根据这个html来构建DOM树 -&gt; 遇到JS脚本和外部JS连接 -&gt; 停止构建DOM树 -&gt; 执行和下载相应的代码(阻塞) (推荐JS代码应该放在html代码的后面) 构建CSS对象模型树(CSSOM) -&gt;和DOM树合并为渲染树 布局 -&gt; 定各个元素的位置和尺寸 web 性能优化性能测试 chrome f12? 第三方? 降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。 加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。 渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。 react?","link":"/2020/08/18/%E9%9D%A2%E8%AF%95-%E7%BD%91%E7%BB%9C/"},{"title":"This, Call, Aplly, Bind.","text":"在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数中的this指向。 bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 this的理解一个易错点: 123456function a(){ var user = \"xinyuan\"; console.log(this.user); //undefined console.log(this); //Window}a(); 按照我们上面说的this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，等价于window.a(); why?call,apply,bind干什么的？为什么要学这个？ 一般用来指定this的环境，在没有学之前，通常会有这些问题。 123456789var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); }}var b = a.fn; //b获取了a.fn的方法内容,但是this只有被调用的时候才会被确定b(); //undefined 想打印对象a里面的user却打印出来undefined? 其实也就是windows在调用a.fn(); //xinyuan what?1、call() 语法: someObj.call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 将someObj的this指针修改为thisObj对象. 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;b.call(a); call方法除了第一个参数以外还可以添加多个参数，如下： 123456789var a = { user:&quot;xinyuan&quot;, fn:function(e,ee){ console.log(this.user); //xinyuan console.log(e+ee); //3 }}var b = a.fn;b.call(a,1,2); 2、apply() apply方法和call方法有些相似，它也可以改变this的指向 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;b.apply(a); 同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组，如下： 123456789var a = { user:\"xinyuan\", fn:function(e,ee){ console.log(this.user); //xinyuan console.log(e+ee); //11 }}var b = a.fn;b.apply(a,[10,1]); 注意如果call和apply的第一个参数写的是null，那么this指向的是window对象 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this); //Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…} }}var b = a.fn;b.apply(null); 3、bind() bind方法返回的是一个修改过后的函数。 123456789var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;var c = b.bind(a);c(); //xinyuan ok，同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。 12345678910var a = { user:\"xinyuan\", fn:function(e,d,f){ console.log(this.user); //xinyuan console.log(e,d,f); //10 1 2 }}var b = a.fn;var c = b.bind(a,10);c(1,2); 总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。 Application（2） 12345678910111213141516function Animal(){ this.name=\"animal\"; this.showName=function(){ console.log(this.name); } } function Dog(){ this.name=\"dog\"; } var animal=new Animal(); var dog=new Dog(); //animal.showName() 对应\"animal\"animal.showName.call(dog);//输出：dog 在上面的代码中，我们可以看到Dog里并没有showName方法，那为什么（this.name）的值是dog呢？ 关键就在于最后一段代码（animal.showName.call(dog)），意思是把animal的方法放到dog上执行，也可以说，把animal 的showName()方法放到 dog上来执行，所以this.name 应该是 dog。 （3）继承 12345678910111213function Animal(name){ this.name=name; this.showName=function(){ console.log(this.name); } } function Dog(name){ Animal.call(this,name); } var dog=new Dog(\"Crazy dog\"); dog.showName();输出：Crazy dog Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么Dog就能直接调用Animal的所有属性和方法。","link":"/2020/08/17/This,%20Call,%20Aplly,%20Bind/"},{"title":"Quick Sort &amp; Merge Sort","text":"快速排序 和 归并排序 都是采用分治法（Divide and Conquer）的非常典型的应用。 Quick Sort vs Merge Sort快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法, 是采用分治法（Divide and Conquer）的一个非常典型的应用。 归并排序的实现由两种方法： 自上而下的递归 recursion（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代 iteration； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 具体实现快排总体逻辑: 12345678910111213function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) { partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); } return arr;} partition实现: 123456789101112function partition(arr, left ,right) { // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) { if (arr[i] &lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index-1;} 归并排序recursion实现: 123456789101112131415161718192021function merge(leftArr, rightArr){ var result = []; while (leftArr.length &gt; 0 &amp;&amp; rightArr.length &gt; 0){ if (leftArr[0] &lt; rightArr[0]) result.push(leftArr.shift()); //把最小的最先取出，放到结果集中 else result.push(rightArr.shift()); } return result.concat(leftArr).concat(rightArr); //剩下的就是合并，这样就排好序了 } function mergeSort(array){ if (array.length == 1) return array; var middle = Math.floor(array.length / 2); //求出中点 var left = array.slice(0, middle); //分割数组 var right = array.slice(middle); return merge(mergeSort(left), mergeSort(right)); //递归合并与排序 } var arr = mergeSort([32,12,56,78,76,45,36]);console.log(arr); // [12, 32, 36, 45, 56, 76, 78] iteration实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function mergeSort(arr){ if(arr.length&lt;2){ return; } //设置子序列的大小 var step=1; var left,right; while(step&lt;arr.length){ left=0; right=step; while(right+step&lt;=arr.length){ mergeArrays(arr,left,left+step,right,right+step); left=right+step; right=left+step; } if(right&lt;arr.length){ mergeArrays(arr,left,left+step,right,arr.length); } step*=2; } return arr;}//对左右序列进行排序function mergeArrays(arr,startLeft,stopLeft,startRight,stopRight){ // 建立一个左、右数组 var rightArr=new Array(stopRight-startRight+1); var leftArr=new Array(stopLeft-startLeft+1); // 给右数组赋值 k=startRight; for(var i=0;i&lt;(rightArr.length-1);++i){ rightArr[i]=arr[k]; ++k; } // 给左数组赋值 k=startLeft; for(var i=0;i&lt;(leftArr.length-1);++i){ leftArr[i]=arr[k]; ++k; } //设置哨兵值，当左子列或右子列读取到最后一位时，即Infinity，可以让另一个剩下的列中的值直接插入到数组中 rightArr[rightArr.length-1]=Infinity; leftArr[leftArr.length-1]=Infinity; var m=0; var n=0; // 比较左子列和右子列第一个值的大小，小的先填入数组，接着再进行比较 for(var k=startLeft;k&lt;stopRight;++k){ if(leftArr[m]&lt;=rightArr[n]){ arr[k]=leftArr[m]; m++; } else{ arr[k]=rightArr[n]; n++; } }}// 测试数据var nums=[6,10,1,9,4,8,2,7,3,5];console.log(mergeSort(nums)); 疑问 空间复杂度如何分析!!!! 与朱博抡交流得知: 对于快排, 尽管每次quicksort都只使用常量, 但一共log(n)轮累积计算, 空间复杂度为O(log n).","link":"/2020/08/16/Quick%20Sort%20&%20Merge%20Sort/"},{"title":"GundamFans V1.4","text":"更新: route refactoring: 将各类别route封装在不同模块中 data association: 增加user, comment 数据关联 准备秋招, 未完待续… route refactoring1234let express = require(\"express\");let router = express.Router(); //使用router替代app//...module.exports = router; 12commentRouter = require(\"./routes/comment\"),app.use(commentRouter); 注意require时的路径问题! 用户权限设计只有登录状态可以进行: 增加评论(自动记录评论用户名) 增加新的机体信息 非登录状态可以进行: 浏览机体信息 设计思路: 对get&amp;post route均进行限制, 仅响应登录状态的request. 增加user 与 comment 的数据关联修改设计comment model 中的author属性: 1234author: { id:{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }, //对应User model的唯一标志_id username: String, //由于经常使用,所以专门提取出来 }, 修改在route中create comment的步骤: 12345let newcomment = { text: req.body.comText, author:{id:req.user._id, username: req.user.username } }comment.create(newcomment,...","link":"/2020/08/14/GundamFansV1.4/"},{"title":"GundamFans V1.3","text":"更新: 增加authentication 依赖库安装123npm i passportnpm i passport-localnpm i passport-local-mongoose UserSchema设计123456789101112let mongoose = require(&quot;mongoose&quot;);let passportLocalMongoose = require(&quot;passport-local-mongoose&quot;);let UserSchema = new mongoose.Schema({ username: String, password: String});//为User植入authentication各种方法UserSchema.plugin(passportLocalMongoose);module.exports = mongoose.model(&quot;User&quot;,UserSchema); 值得注意的是, UserSchema中的属性名称必须为username和password passport config12345678910app.use(require(&quot;express-session&quot;)({ secret: &quot;My favorite gundam is exia!&quot;, resave: false, saveUninitialized: false,}));app.use(passport.initialize());app.use(passport.session());passport.use(new LocalStrategy(User.authenticate()));passport.serializeUser(User.serializeUser());passport.deserializeUser(User.deserializeUser()); Routes设计register设计: 12345678910111213141516171819202122232425//===============//AUTH ROUTES//===============//show register formapp.get(&quot;/register&quot;,function(req,res){ res.render(&quot;register&quot;);})//handle sign up requestapp.post(&quot;/register&quot;,function(req,res){ let newUser = new User({username: req.body.username}); //form与User中必须定义为username User.register(newUser, req.body.password, function(err, user){ if(err){ console.log(err); res.render(&quot;register&quot;); } else { //验证登录 passport.authenticate(&quot;local&quot;, { successRedirect: '/wiki', failureRedirect: '/register', })(req, res, function(){ }) } })}) 在 register form中设计表项name 也必须为”username” “password”对应. login设计: 12345678910111213//show login formapp.get(&quot;/login&quot;,function(req,res){ res.render(&quot;login&quot;);})//handle login request//app.post(&quot;login&quot;, middleware, callback)app.post(&quot;/login&quot;,passport.authenticate(&quot;local&quot;, { successRedirect: '/wiki', failureRedirect: '/login', }), function(req,res){}) 处于middleware的函数会被立即执行. passport.authenticate直接根据login form中的username 和 password 判断能否登录. 加密页面设置设计函数isLoggedIn()如下: 123456function isLoggedIn(req,res,next){ if(req.isAuthenticated()){ return next();//继续执行后续代码(下一个函数) } res.redirect(&quot;/login&quot;);} 将该函数当做middleware function传入需要登录的页面对应的routes, 即可实现进入该页面前验证登录状态功能. 如: 需要用户登录之后才可以使用评论功能: 1app.get(&quot;/wiki/:id/comment/new&quot;,isLoggedIn ,function(req,res){ 页面元素响应用户状态为了实现页面根据用户状态不同而现实不同内容, 则需要将user信息传入对应route, 在express route中天然req.user即是用户信息结构体, 包含username, _id信息. 可以以参数形式传入: 1res.render(&quot;index&quot;,{User: req.user}); 对于实现navbar随着用户状态而选择显示”Login”或”Logout”的功能, 需要在每个页面中都传入req.user数据. 为了简便, 可以使用app.use()功能, 该功能将参数函数当做middleware, 在每个route执行前运行, res.locals.currentUser设置res本地变量供ejs直接使用. 1234app.use(function(req,res,next){ res.locals.currentUser = req.user; next();}); 易错点 定义UserSchema时属性必须为username, password. ejs的form中, 对应input的name也必须为username, password. bootstrap 4 的navbar需要靠右排列时, 使用.ml-auto类. navbar toggle dont work -&gt; include JQuery!!!","link":"/2020/08/13/GundamFansV1.3/"},{"title":"GundamFans V1.2","text":"更新: Comment模块设计: Data Association in Mongoose, 为了安全性使用expressSanitizer Code Refactoring: 划分module, RESTful routing, seedDB()函数生成初试测试数据 RESTful routesRESTful routes 是一种约定俗成的router定义方式, 对应CURD(Create, Update, Read, Delete)的需求, 设计方式如下: HTTP VERB ROUTE Action Used For GET ‘/wiki’ index action index page to display all gundam info GET ‘/wiki/new’ new action displays create gundam info form POST ‘/wiki’ create action creates one gundam GET ‘/wiki/:id’ show action displays one gundambased on ID in the url GET ‘/wiki/:id/edit’ edit action displays edit form based on ID in the url PUT ‘/wiki/:id’ update action replaces an existing article based on ID in the url DELETE ‘/wiki/:id’ delete action deletes one article based on ID in the url PATCH ‘/wiki/:id’ update action modifies an existing article based on ID in the url Comment Module模式设计12345678910let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: {type:String, default:\"Not available\"}, comments: [{ type: mongoose.Schema.Types.ObjectId, ref: 'comment' }] //一个机体可以有多条评价,“`ref`”告知模式分配哪个模型给该字段。});let commentSchema = new mongoose.Schema({ author: String, text: String,}); 读入数据时, 使用populate方法将 id 替换为实际数据: 1234567891011gundamMS.findById(req.params.id) //搜索结果为json的集合 .populate('comments')// 使用作者 id 填充实际作者信息 .exec(function(err,findms){//exec使用回调函数 if(err){ console.log(err); } else { console.log(findms); res.render(\"show\",{ms:findms}); } });//使用时comments对象由id的数组,变为结构体的数组 安全性expressSanitizer为了使评论格式多样, 在show页面的ejs中, 使用&lt;%- %&gt;进行显示输出, 为了避免用户输入&lt;script&gt;&lt;/script&gt;导致执行恶意代码, 使用expressSanitized: 12345678npm i express-sanitizedlet expressSanitized = require(\"express-sanitized\");app.use(bodyparser.urlencoded({extended:true}));app.use(expressSanitized());//bodyparser之后//&lt;script&gt;alert(\"you have been hacked\")&lt;/script&gt;//&lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒消除script部分 data association in mongoose知识补充模式声明时, 属性可以包含其他模式. 1234567891011121314//模式定义const schema = new Schema({ name: String, binary: Buffer, living: Boolean, updated: { type: Date, default: Date.now }, age: { type: Number, min: 18, max: 65, required: true }, mixed: Schema.Types.Mixed, _someId: Schema.Types.ObjectId, //其他模式 array: [], ofString: [String], // 其他类型也可使用数组 nested: { stuff: { type: String, lowercase: true, trim: true } }}) ObjectId：表示数据库中某一模型的特定实例。例如，一本书可能会使用它来表示其作者对象。它实际只包含指定对象的唯一 ID（_id） 。可以使用 populate() 方法在需要时提取相关信息。 Code Refactoring将schema分到单独的文件, 使用module.exports =..来设置出口变量. 同时设计seedDB()函数为数据库增加原始数据. 注意 :为了保证操作的运行次序, 必须把存在先后次序的操作放在call back中. 1234567891011121314151617181920212223242526272829303132function seedDB(){ //remove all gundamMS.remove({},function(err){ if(err){ console.log(err); } else { console.log(\"removed all MS\"); //add MS data.forEach(function(e){ gundamMS.create(e,function(err,newms){ if(err){ console.log(err); } else { console.log(e); comment.create({ author: \"TOM\", text: \"I love this gundam!!!!!\" }, function(err,newcomment){ if(err){ console.log(err); } else{ newms.comments.push(newcomment); newms.save(); } } ) } }) }) } });}","link":"/2020/08/11/GundamFansV1.2/"},{"title":"GundamFans V1.1","text":"GundamFans意在建立一个高达动漫同好分享网站, 分享自己喜爱的高达机体. 后端主体为nodeJS的express框架, 数据库采用mongoDB, 使用mongoose库进行操作. 前端部分使用ejs来编写网页, 使用bootstrap进行装饰, 具有较好的整合性. 主体文件文件树结构: D:.│ index.js│ package-lock.json│ package.json ├───public //需要app.use(express.static(“public”));指示express来serve public目录│ global.css //全局css设置│└───views //express 默认文件夹 │ index.ejs │ landing.ejs │ newms.ejs │ show.ejs │ └───partials //公用代码 header.ejs tail.ejs ├───node_modules(略) 关键点 框架与库的区别 &lt;%- include(“partials/header”) %&gt;实现头尾部ejs代码公用 post指令无法直接解析req.body.param, 需要body-parser库 ejs中&lt;% %&gt;为逻辑代码不显示, &lt;%= %&gt;为显示代码, &lt;%- %&gt;显示且作为html运行? &lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒 代码逻辑首先在本地开启mongoDB, mongod npm库依赖: 123456const { render } = require(\"ejs\");let express = require(\"express\"), app = express(), bodyparser = require(\"body-parser\"); mongoose = require(\"mongoose\"); 相关设置与端口监听: 123456789//指示express来serve public目录app.use(express.static(\"public\"));// 设置使得body自动被parse,可以直接使用req.body.nameapp.use(bodyparser.urlencoded({extended:true}));//默认使用ejs解析views内容app.set(\"view engine\",\"ejs\");app.listen(3000,function(){ console.log(\"gundam runnig\");}) 连接mongoDB, mongoose.connect(&quot;mongodb://localhost:27017/gundam_fans&quot;,{useUnifiedTopology: true,useNewUrlParser: true }); 构建机体视图schema, 构建模型变量. 123456let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: String});let gundamMS = mongoose.model(\"gundamMS\",gundamMSSchema); Router设计: url HTTP verb purpose 对应ejs / get 加载Landing Page landing /wiki get 展示所有机体信息 index /wiki post 根据页面body表单信息创建机体, redirect(“/wiki”) - /wiki/new get 加载机体创建表格, &lt; form action=”/wiki” method=”POST” &gt; newms /wiki/:id get 加载id对应机体详情页 show 具体实现: /wiki get 实现 1234567891011app.get(\"/wiki\",function(req,res){ //获取所有ms信息 //find() gundamMS.find({},function(err,mslist){ if(err){ console.log(err); } else { res.render(\"index\",{mslist: mslist}); } })}) 搜索结果mslist, 传入index页, 取出单个结构即为gundamMSSchema, 多了一个”_id”属性. e.name等属性直接显示, e_id作为参数传入链接MoreInfo. a href=&quot;/wiki/&lt;%= e._id%&gt;&quot; 通过点击MoreInfo, 进入机体详情页: 123456789101112//显示更多机体信息app.get(\"/wiki/:id\",function(req,res){ //index中的btn link包含_id,利用_id去获取description,(req.params.id获取域名中的参数) gundamMS.findById(req.params.id,function(err,findms){ if(err){ console.log(err); } else { res.render(\"show\",{ms:findms}); } }) }) 对于url中带有的参数:id使用 req.params.id进行访问. 新建机体信息的设置: 首先是在wiki/new下rendernewms页面, 在该页面下提供form. 该表格将信息以POST报文的形式传给/wiki页面. 1234567891011121314&lt;form action=\"/wiki\" method=\"POST\" &gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"msname\" placeholder=\"MS name\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"msimg\" placeholder=\"MS picture url\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"description\" placeholder=\"MS description\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-block\"&gt;GO!&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; /wiki对POST报文进行响应: 12345678910111213141516app.post(\"/wiki\",function(req,res){ let newms = { name:req.body.msname, img:req.body.msimg, description:req.body.description, } gundamMS.create(newms,function(err,newlycreated){ if(err){ console.log(err); } else { res.redirect(\"/wiki\"); } }) }) 其中注意页面信息由req.body.msname获取, 注意此处需要提前引入bodyparser依赖: 123bodyparser = require(\"body-parser\");// 设置使得body自动被parse,可以直接使用req.body.nameapp.use(bodyparser.urlencoded({extended:true})); MongoDB使用整理:首先在本地开启mongoDB, mongod 连接mongoDB, mongoose.connect(&quot;mongodb://localhost:27017/gundam_fans&quot;,{useUnifiedTopology: true,useNewUrlParser: true }); 构建机体视图schema, 构建模型变量. 1234567let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: String});// 使用模式“编译”模型let gundamMS = mongoose.model(\"gundamMS\",gundamMSSchema); 第一个参数是为模型所创建集合的别名（Mongoose 将为 SomeModel 模型创建数据库集合），第二个参数是创建模型时使用的模式。 创建和修改文档插入新数据操作: 123456789101112gundamMS.create( {name:\"ASW-G-08 Gundam Barbatos\", img:\"...\", description:\"...\" },function(err,ms){ if(err){ console.log(err); } else{ console.log(ms); }}); 或使用save(): 123456789// 创建一个 SomeModel 模型的实例const awesome_instance = new SomeModel({ name: '牛人' });// 传递回调以保存这个新建的模型实例awesome_instance.save( function (err) { if (err) { return handleError(err); } // 已保存}); 可以使用“圆点”加字段名来访问、修改新记录中的字段。修改后必须调用 save() 或 update() 以将改动保存回数据库。 12345678910// 使用圆点来访问模型的字段值console.log(awesome_instance.name); // 控制台将显示 '也是牛人'// 修改字段内容并调用 save() 以修改记录awesome_instance.name = \"酷毙了的牛人\";awesome_instance.save( function(err) { if (err) { return handleError(err); } // 已保存}); 搜索纪录 findById()：用指定 id 查找文档（每个文档都有一个唯一 id）。 findOne()：查找与指定条件匹配的第一个文档。 findByIdAndRemove()、findByIdAndUpdate()、findOneAndRemove()、 findOneAndUpdate()：通过 id 或条件查找单个文档，并进行更新或删除。以上是更新和删除记录的便利函数。 查找获取list of elements: 1234567gundamMS.find({},function(err,mslist){ if(err){ console.log(err); } else { console.log(mslist); } }) 查找获取单个element: 1234567gundamMS.findById(req.params.id,function(err,findms){ if(err){ console.log(err); } else { res.render(\"show\",{ms:findms}); }}) 进阶: 以下代码展示了如何在数据库中找到所有网球运动员，并返回运动员姓名和年龄字段。 123456789101112const Athlete = mongoose.model('Athlete', yourSchema);// SELECT name, age FROM Athlete WHERE sport='Tennis'Athlete.find( { 'sport': 'Tennis' }, 'name age', function (err, athletes) { if (err) { return handleError(err); } // 'athletes' 中保存一个符合条件的运动员的列表 }); 若像上述代码那样指定回调，则查询将立即执行。搜索完成后将调用回调。 若未指定回调，则 API 将返回 Query 类型的变量。可以使用该查询对象来构建查询，随后使用 exec() 方法执行（使用回调）。 12345678910111213141516171819202122232425262728// 寻找所有网球运动员const query = Athlete.find({ 'sport': 'Tennis' });// 查找 name, age 两个字段query.select('name age');// 只查找前 5 条记录query.limit(5);// 按年龄排序query.sort({ age: -1 });// 以后某个时间运行该查询query.exec(function (err, athletes) { if (err) { return handleError(err); } // athletes 中保存网球运动员列表，按年龄排序，共 5 条记录})//等价于Athlete. find(). where('sport').equals('Tennis'). where('age').gt(17).lt(50). // 附加 WHERE 查询 limit(5). sort({ age: -1 }). select('name age'). exec(callback); // 回调函数的名字是 callback 查询还能做更多。请参阅 查询（Mongoose 英文文档） 公用html代码header部分 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;I'm Gundam!!!&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"/global.css\"&gt; &lt;/head&gt; &lt;!-- 设计navbar --&gt; &lt;body&gt; tail部分 123&lt;p class=\"text-center\"&gt;Copyright: XinyuanCai.07/2020&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 升级req.body.blog blog[name] blog[img] npm i express-sanitizer 1234567891011form action: /xx/_id?method=PUT method=\"POST\"let expressSanitizer = require(\"express-sanitizer\");let methodOverride = require(\"method-override\");//after bodyparserapp.use(expressSanitizer())app.use(methodOverride(\"_method\"))// 博客的content 我们支持html格式,则...//&lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒消除script部分","link":"/2020/08/07/GundamFansV1.1/"},{"title":"Tree BFS DFS","text":"使用callback以及call技术, 写出标准化的BFS,DFS. 以及扩展性极强的contain. Tree基本数据结构: 12345678910//JS treefunction Node(data){ this.data = data; this. parent = null; this.children = [];}function Tree(data){ this.root = new Node(data);} recurse DFS: 1234567891011Tree.prototype.traverseDF = function(callback){ ( function recurse(currNode){ let length = currNode.children.length; callback(currNode);//先序遍历 for(let i = 0; i&lt;length; i++){ recurse(currNode.children[i]); //当只有两个children时,插在中间则为中序遍历 } //callback(currNode);//后序遍历 } )(this._root);}; 立即使用树的根节点作为其参数调用recurse。 此时，currentNode指向当前节点。 进入for循环并且从第一个子节点开始，每一个子节点都迭代一次currentNode函数。 在for循环体内，使用currentNode的子元素调用递归。 确切的子节点取决于当前for循环的当前迭代。 当currentNode不存在子节点时，我们退出for循环并callback我们在调用traverseDF（callback）期间传递的回调。 queue BFS: 1234567891011121314//queue BFSTree.prototype.traverseBF = function(callback){ let queue = []; queue.push(this._root); let currNode = queue.shift(); while(currNode){ let length = currNode.children.length; for(let i = 0; i&lt;length; i++){ queue.push(currNode.children[i]); } callback(currNode); currNode = queue.shift(); }} 创建 Queue的实例。 将调用traverseBF(callback)的节点添加到Queue的实例。 定义一个变量currentNode并且将他的值初始化为刚才添加到队列里的node 当currentNode指向一个节点时，执行wille循环里面的代码。 用for循环去迭代currentNode的子节点。 在for循环体内，将每个子元素加入队列。 获取currentNode并将其作为callback的参数传递。 将currentNode重新分配给正从队列中删除的节点。 直到currentNode不在指向任何节点-也就是说树中的每个节点都访问过了-重复4-8步。 自定义的contain contains(callback, traversal)接收两个参数：搜索的数据和遍历的类型。 123Tree.prototype.contains = function(callback, traversal) { traversal.call(this, callback);}; 使用示例： 123456// tree is an example of a root nodetree.contains(function(node){ if (node.data === 'two') { console.log(node); }}, tree.traverseBF); 深度优先遍历问题二叉树的所有路径-257 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 123456789101112输入: 1 / \\2 3 \\ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3复制代码 来源：力扣（LeetCode） 链接：leetcode-cn.com/problems/bi… 路径(n)为当前node, 与路径(n.left)和路径(n.right)的拼接. 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {string[]} */var binaryTreePaths = function(root) { let res = []; if(!root){return res}; if((!root.left)&amp;&amp;(!root.right)){return [root.val]}; let left_result = binaryTreePaths(root.left); let right_result = binaryTreePaths(root.right); left_result.forEach(e =&gt;{ res.push(root.val+&quot;-&gt;&quot;+e); }); right_result.forEach(e =&gt;{ res.push(root.val+&quot;-&gt;&quot;+e); }); return res;}; 广度优先遍历（BFS）问题在每个树行中找最大值-515 leetcode-cn.com/problems/fi… 您需要在二叉树的每一行中找到最大的值。 1234567891011输入: 1 / \\ 3 2 / \\ \\ 5 3 9输出: [1, 3, 9]复制代码","link":"/2020/08/04/Tree%20BFS%20DFS/"},{"title":"LC_training(2)","text":"易错点 forEach()函数体中,无法使用return终止运行,也不能使用break,continue. 应该使用其他语法. 123456MyHashSet.prototype.contains = function(key) { this.set.forEach(function(e){ if(e == key) return true; }); return false;}; 今天遇到一个还挺厉害的简单题解法: 有效的括号-20 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。其实就是栈问题.leetcode-cn.com/problems/va… 常规写法: 略 进阶写法: 12345678910111213141516171819202122232425var isValid = function(s) { let map = { \"{\":\"}\", \"(\":\")\", \"[\":\"]\" }; var stack = []; let len = s.length; let top = \"\"; for (let char of s){ //char of s将s当做一个数组??如何办到的 if (map[char]) { //利用map取代一个个判断条件 stack.push(char); top = char; } else { if(char == map[top]){ //利用map构建对应关系 stack.pop(); top = stack[stack.length-1]; } else return false; } } return !stack.length; //return的条件简化};","link":"/2020/08/02/LeetCode%E5%BF%83%E5%BE%97(2)/"},{"title":"LinkedList basis","text":"简单的链表训练 链表基本实现:12345678910111213141516171819202122232425262728293031323334353637//结点的构造函数function Node(e){ this.e = e; this.next = null;}//搜索item元素所在nodefunction find (item){ let currNode = this.head; while(currNode.e!=item){ currNode = currNode.next; } return currNode;}//在item元素之前插入newelementfunction insert (newElement,item){ let newNode = new Node(newElement); let target = this.find(item); newNode.next= target.next; target.next = newNode;}function display(){ let currNode = this.head; while(currNode){ console.log(currNode.e); currNode = currNode.next; }}//链表的构造函数function LList() { this.head = new Node('head');//头结点 this.find = find; //定义函数? this.insert = insert; this.display = display;} 典型例题:两两交换链表中的节点-24 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 12给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.复制代码 来源：力扣（LeetCode） 链接：leetcode-cn.com/problems/sw… 1234567891011121314//实现对链表两个节点的交换function switchwithnext(node){ if(!node) return null; let nextnode = node.next; if(!nextnode) return node; node.next = switchwithnext(nextnode.next); nextnode.next = node; return nextnode;}function solution(head){ let res = switchwithnext(head); return res;} 难吗?还行,重点是next的理解,要画图.","link":"/2020/07/31/LinkedList/"},{"title":"LC_training(1)","text":"犯过的那些错误 一个专属JS的不起眼的坑!!! 1234for(var i in nums){ if(nums[i]==nums[i+1]){ ... } 上述代码中nums[i+1]结果undifined, 因为for in遍历的原理是什么呢? 其实是把nums数组当做Obejct(一个键值对结构), 其中i 是对于其key的遍历, 因此i 其实是字符串”0”, 而i+1则表示”01”, 自然是找不到结果. 对此问题我们深入研究, 123456 const arr = [ “ a”，“ b”，“ c” ]; arr.test = “坏”；//既然数组是object,就可以添加非数字属性 for (let i in arr) { console.log(i+\":\"+ arr[i]); // 打印\"0:a, 1:b, 2:c, test:bad\"} 因此在 Js的数组遍历中,我们应该避免使用for/in, 而可以选择for/of替代. 123456 for (const element of arr) { console.log(element); } for (let i = 0; i &lt; arr.length; ++i) { console.log(arr[i]);} 此外, for，for/in与for/of会保留外部作用域的this。 对于forEach， 除非使用箭头函数，它的回调函数的 this 将会变化。 1234567891011 \"use strict\"; const arr = [\"a\"]; arr.forEach(function() { console.log(this); // 打印undefined }); arr.forEach(() =&gt; { console.log(this); // 打印{}}); JS对象 与 哈希表: js中的对象是基于哈希表结构的,而哈希表的查找时间复杂度为O(1),所以很多人喜欢用对象来做映射,减少遍历循环. 对于找数组重复元素, 我们的核心是利用key存储数据, 利用value来记录该元素是否存在(bool), 但是需要注意的是key值会被转化为字符串, 因此数组中元素类型应该保持一致. 核心: object, 是属性名-属性值的键值对, 对于属性名(字符串)的ASII码进行哈希算法的应用, 这样就构建了高效(O(1)时间存取)的HashMap结构了. 一个很蠢的问题: 123let tmp = nums[i];nums[i] = nums[nums[i]];nums[nums[i]] = tmp; 经常在自身哈希的题目中犯错, nums[i]的值被改变了呀! 应该提前将nums[i]的值保存下来: 12let numi = nums[i];[nums[i],nums[numi]] = [nums[numi],nums[i]]//解构赋值语法ES6 拼写：querySelector,querySelectorAll,addEventListener, querySelectorAll的函数返回为 Nodelist, 千万不要直接使用！！！ 题解 找出数组中重复的数字。长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 排序之后遍历判断相邻元素: nlogn, n var findRepeatNumber = function(nums) { nums.sort(); for(let i=0; i&lt;nums.length;i++){ if(nums[i]==nums[i+1]){ return 9; } } return 0; }; &lt;!--￼6--&gt; 采用基于对象的hash映射, n, n (基于假设set存取均为O(1)): var findRepeatNumber = function(nums) { let obj = {}; for(num of nums){ if(!obj[num]){ obj[num]=true; } else{ return num; } } }; 所有数字都在 0 ～ n-1 的范围内。因此不需要额外开辟空间，每次遍历时，检查当前元素是否放在了正确位置上（例如元素 i 应该放在下标为 i 的位置上）。如果放在了正确位置上，那么继续循环。否则： 下标为 num 的元素 == num，说明当前元素 num 是重复的，直接返回下标为 num 的元素 != num，交换当前元素和下标为 num 的元素，将当前元素放入到正确位置上 n, 1 (基于假设set存取均为O(1)) 二维数组中的查找观察大小规则, 利用单调性查找元素!","link":"/2020/07/30/LeetCode%E5%BF%83%E5%BE%97(1)/"},{"title":"Arrow Func &amp; set map","text":"箭头函数箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 应用场合:普通函数会重新绑定this, 箭头函数不会重新绑定this. 根据需求选择…… 面试经典: 当前this是什么? 举例子: 12345678910111213document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听})-----------------------------------------------------------console.log(this) //输出windowdocument.getElementById(\"the-button\").addEventListener(\"click\",()=&gt;{ console.log(this);//输出的是window this.classList.add(\"bigger\");//添加监听失败}) 原因是箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 这里该函数作为addEventListener的参数, 其实是被button 调用 更进一步的例子: 12345678910111213141516171819202122232425262728293031323334document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听 //希望等待一秒后变化 setTimeout(function(){ console.log(this); //why! 指向window???? 因为这里发生函数调用,则重新绑定,而setTimeout不是被别人调用的,所以是window this.innerHTML = \"clicked\"; })})--------解决方法 一:保存临时this (很乱)-------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); var tmpthis = this; setTimeout(function(){ console.log(tmpthis); tmpthis.innerHTML = \"clicked\"; })}) --------最好的方法: 箭头函数替代--------------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); setTimeout(()=&gt;{ console.log(this); this.innerHTML = \"clicked\"; })}) ==待突破的难点:== ==this 的值是什么?== 12345const ages =[14,19,21];ages.map(age=&gt; \"his age is \"+age );ages.filter(age=&gt; age&gt;18); set123456789101112const numSet = new Set();numSet.add(e) //返回setnumSet.delete(e) //返回boolnumSet.has(e) //返回boolnumSet.size //数组才是length//遍历 或者for of (原本的for in)numSet.forEach(number=&gt; console.log(number)) map123456789101112131415161718const person = new Map();person.set(\"name\",\"laobi\")person.set(\"age\",18) //value可以是不同类型的person.get(\"name\") //返回valueperson.size //数组才是length person.has(\"name\") //返回bool//添加重复的key呢?person.set(\"name\",\"xiaocai\") //将会替换原本的valueperson.delete(\"age\") //返回bool//遍历 或者for of (原本的for in)person.forEach(箭头函数)","link":"/2020/07/30/Arrow%20Func%20&%20set%20map/"},{"title":"Todo-List","text":"一个简单的利用JQuery实现+CSS修饰的静态网页备忘录. 成品 技术重点 JQuery对click, keypress事件的监听 复习bootstrap与css 技术难点 onclick只能对已经存在的元素监听 解决方案: 1234//$(\"li\").on(\"click\",function(){ //尽管使用on,但是还是没法应用到新的li中,因为$(li)绑定行为一开始就执行了,此时只有三个li.$(\"ul\").on(\"click\",\"li\",function(){ //而绑定ul之后, 在click时,再去确认click是其中的哪个li,则可以解决该问题.即$()中的元素一定一开始就要存在,因此此类问题绑定其父节点即可 $(this).toggleClass(\"finished\");}) span元素存在于ul元素中, 点击span会触发ul的监听执行函数 解决方案: e.stopPropagation(); 中断回调传递 1234567//remove evert when click X before it$(\"ul\").on(\"click\",\"span\",function(e){ $(this).parent().fadeOut(function(){ $(this).remove(); //此处使用this,而不是parent,因为已经在fadeOut中,此时this已经指向parent }); //parent()方法返回父元素 e.stopPropagation(); //span处于li,ul,body中,则事件e可能导致其他回调函数,终止传播函数stopPropagation由jQuery提供}) JS代码对html内容的影响 解决方案:$(“ul”).append()函数, 为ul增加item 12345678$(\"input\").on(\"keypress\",function(e){ if(e.which == 13){ let newevent = $(this).val(); $(this).val(\"\"); //清空输入栏 $(\"ul\").append(\"&lt;li&gt;&lt;span&gt;&lt;i class=\\\"fa fa-trash\\\" aria-hidden=\\\"true\\\"&gt;&lt;/i&gt; &lt;/span&gt;\"+newevent+\"&lt;/li&gt;\"); }}) 如何设计hover滑动淡出淡入特效, 需要结合css和JQuery 12345678910111213span{ transition: 0.3s linear; height: 35px; width: 0; opacity: 0; /*设置能见度,优化显示*/}/*有意思的写法 表示hover的li里面的span*/li:hover span{ width: 35px; opacity: 1.0;} 关于fadeout之后remove的研究 123456789//effect 部分$(\"button\").on(\"click\",function(){ $(\"div\").fadeOut(1000,function(){//fade的同时执行函数 //fade只是隐藏显示,在html中仍然存在 //$(this).remove 从html中删除 }); $(\"div\").remove();//不妥,参考setInterval事件队列,fade未执行完成就删除了 })","link":"/2020/07/28/todolist/"}],"tags":[{"name":"ES6特性","slug":"ES6特性","link":"/tags/ES6%E7%89%B9%E6%80%A7/"},{"name":"LC","slug":"LC","link":"/tags/LC/"},{"name":"易错","slug":"易错","link":"/tags/%E6%98%93%E9%94%99/"},{"name":"Full Stack","slug":"Full-Stack","link":"/tags/Full-Stack/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"ejs","slug":"ejs","link":"/tags/ejs/"},{"name":"mongoDB","slug":"mongoDB","link":"/tags/mongoDB/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"Front-End","slug":"Front-End","link":"/tags/Front-End/"},{"name":"JQuery","slug":"JQuery","link":"/tags/JQuery/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"url过程","slug":"url过程","link":"/tags/url%E8%BF%87%E7%A8%8B/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"react","slug":"react","link":"/tags/react/"}],"categories":[{"name":"闲谈","slug":"闲谈","link":"/categories/%E9%97%B2%E8%B0%88/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"Application","slug":"Application","link":"/categories/Application/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"react","slug":"react","link":"/categories/react/"}]}