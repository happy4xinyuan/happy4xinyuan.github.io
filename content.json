{"pages":[],"posts":[{"title":"Beginning of Everything 起点","text":"“hust&gt; rm -rf”, 了结过往, 面向未来, 是我为HUST计算机学院设计的毕业衫图案 2020年, 没有想象中美好的毕业仪式, 大学四年生活匆匆收场. 本以为最最美好的”大学四年级”结果却是如此孤独寂寥, 假如不是这场疫情所致, 也许现在我已经做好了去美国留学的打算. 在家颓靡的这几个月, 美其名曰”韬光养晦”, 其实也只是浑浑噩噩. 现已是7月底, 大家纷纷找了实习, 而我却迟迟没有迈出这一步. 既然人生这么多遗憾, 为什么不记录下那些美好的时刻呢? 于是乎, 我建立起这个博客, 意在记录那些学习技术过程中的快乐时光. 正如我博客的slogan所言 “have fun with tech“ , 学习技术的过程本身就是一种快乐, 正如男孩学会了积木的拼接, 进而用乐高创造出属于自己的快乐世界. 我也希望在学习的过程中, 记录这些创造性的快乐时刻, 与你们分享技术的乐趣. Go! Go! Xinyuan, explore the Tech &amp; have Fun !","link":"/2020/07/28/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"},{"title":"LC_training(2)","text":"易错点 forEach()函数体中,无法使用return终止运行,也不能使用break,continue. 应该使用其他语法. 123456MyHashSet.prototype.contains = function(key) { this.set.forEach(function(e){ if(e == key) return true; }); return false;};","link":"/2020/08/02/LeetCode%E5%BF%83%E5%BE%97(2)/"},{"title":"LinkedList &amp; Tree BFS DFS","text":"未完待续… 链表基本实现:12345678910111213141516171819202122232425262728293031323334353637//结点的构造函数function Node(e){ this.e = e; this.next = null;}//搜索item元素所在nodefunction find (item){ let currNode = this.head; while(currNode.e!=item){ currNode = currNode.next; } return currNode;}//在item元素之前插入newelementfunction insert (newElement,item){ let newNode = new Node(newElement); let target = this.find(item); newNode.next= target.next; target.next = newNode;}function display(){ let currNode = this.head; while(currNode){ console.log(currNode.e); currNode = currNode.next; }}//链表的构造函数function LList() { this.head = new Node('head');//头结点 this.find = find; //定义函数? this.insert = insert; this.display = display;} 典型例题:两两交换链表中的节点-24 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 12给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.复制代码 来源：力扣（LeetCode） 链接：leetcode-cn.com/problems/sw… 1234567891011121314//实现对链表两个节点的交换function switchwithnext(node){ if(!node) return null; let nextnode = node.next; if(!nextnode) return node; node.next = switchwithnext(nextnode.next); nextnode.next = node; return nextnode;}function solution(head){ let res = switchwithnext(head); return res;} 难吗?还行,重点是next的理解,要画图. Tree基本数据结构: 12345678910//JS treefunction Node(data){ this.data = data; this. parent = null; this.children = [];}function Tree(data){ this.root = new Node(data);} DFS标准: 1Tree 深度优先遍历问题二叉树的所有路径-257 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 123456789101112输入: 1 / \\2 3 \\ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3复制代码 来源：力扣（LeetCode） 链接：leetcode-cn.com/problems/bi… 路径(n)为当前node, 与路径(n.left)和路径(n.right)的拼接. 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {string[]} */var binaryTreePaths = function(root) { let res = []; if(!root){return res}; if((!root.left)&amp;&amp;(!root.right)){return [root.val]}; let left_result = binaryTreePaths(root.left); let right_result = binaryTreePaths(root.right); left_result.forEach(e =&gt;{ res.push(root.val+&quot;-&gt;&quot;+e); }); right_result.forEach(e =&gt;{ res.push(root.val+&quot;-&gt;&quot;+e); }); return res;}; queue实现BFS123456789101112131415function BFS(root){ let res = []; let queue = []; if(!root) return [root.val]; queue.push(root.val); while(queue.length){ let currNode = queue.shift(); res.push(currNode.val); if(currNode.left) queue.push(currNode.left); if(currNode.right) queue.push(currNode.right); } console.log(res); return 0;}","link":"/2020/07/31/%E4%B8%80%E5%A4%9C%E5%AD%A6%E5%AE%8CJS%E6%A0%B8%E5%BF%83LC/"},{"title":"LC_training(1)","text":"犯过的那些错误 一个专属JS的不起眼的坑!!! 1234for(var i in nums){ if(nums[i]==nums[i+1]){ ... } 上述代码中nums[i+1]结果undifined, 因为for in遍历的原理是什么呢? 其实是把nums数组当做Obejct(一个键值对结构), 其中i 是对于其key的遍历, 因此i 其实是字符串”0”, 而i+1则表示”01”, 自然是找不到结果. 对此问题我们深入研究, 123456 const arr = [ “ a”，“ b”，“ c” ]; arr.test = “坏”；//既然数组是object,就可以添加非数字属性 for (let i in arr) { console.log(i+\":\"+ arr[i]); // 打印\"0:a, 1:b, 2:c, test:bad\"} 因此在 Js的数组遍历中,我们应该避免使用for/in, 而可以选择for/of替代. 123456 for (const element of arr) { console.log(element); } for (let i = 0; i &lt; arr.length; ++i) { console.log(arr[i]);} 此外, for，for/in与for/of会保留外部作用域的this。 对于forEach， 除非使用箭头函数，它的回调函数的 this 将会变化。 1234567891011 \"use strict\"; const arr = [\"a\"]; arr.forEach(function() { console.log(this); // 打印undefined }); arr.forEach(() =&gt; { console.log(this); // 打印{}}); JS对象 与 哈希表: js中的对象是基于哈希表结构的,而哈希表的查找时间复杂度为O(1),所以很多人喜欢用对象来做映射,减少遍历循环. 对于找数组重复元素, 我们的核心是利用key存储数据, 利用value来记录该元素是否存在(bool), 但是需要注意的是key值会被转化为字符串, 因此数组中元素类型应该保持一致. 核心: object, 是属性名-属性值的键值对, 对于属性名(字符串)的ASII码进行哈希算法的应用, 这样就构建了高效(O(1)时间存取)的HashMap结构了. 一个很蠢的问题: 123let tmp = nums[i];nums[i] = nums[nums[i]];nums[nums[i]] = tmp; 经常在自身哈希的题目中犯错, nums[i]的值被改变了呀! 应该提前将nums[i]的值保存下来: 12let numi = nums[i];[nums[i],nums[numi]] = [nums[numi],nums[i]]//解构赋值语法ES6 拼写：querySelector,querySelectorAll,addEventListener, querySelectorAll的函数返回为 Nodelist, 千万不要直接使用！！！ 题解 找出数组中重复的数字。长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 排序之后遍历判断相邻元素: nlogn, n var findRepeatNumber = function(nums) { nums.sort(); for(let i=0; i&lt;nums.length;i++){ if(nums[i]==nums[i+1]){ return 9; } } return 0; }; &lt;!--￼6--&gt; 采用基于对象的hash映射, n, n (基于假设set存取均为O(1)): var findRepeatNumber = function(nums) { let obj = {}; for(num of nums){ if(!obj[num]){ obj[num]=true; } else{ return num; } } }; 所有数字都在 0 ～ n-1 的范围内。因此不需要额外开辟空间，每次遍历时，检查当前元素是否放在了正确位置上（例如元素 i 应该放在下标为 i 的位置上）。如果放在了正确位置上，那么继续循环。否则： 下标为 num 的元素 == num，说明当前元素 num 是重复的，直接返回下标为 num 的元素 != num，交换当前元素和下标为 num 的元素，将当前元素放入到正确位置上 n, 1 (基于假设set存取均为O(1)) 二维数组中的查找观察大小规则, 利用单调性查找元素!","link":"/2020/07/30/LeetCode%E5%BF%83%E5%BE%97(1)/"},{"title":"Arrow Func &amp; set map","text":"箭头函数箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 应用场合:普通函数会重新绑定this, 箭头函数不会重新绑定this. 根据需求选择…… 面试经典: 当前this是什么? 举例子: 12345678910111213document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听})-----------------------------------------------------------console.log(this) //输出windowdocument.getElementById(\"the-button\").addEventListener(\"click\",()=&gt;{ console.log(this);//输出的是window this.classList.add(\"bigger\");//添加监听失败}) 原因是箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 这里该函数作为addEventListener的参数, 其实是被button 调用 更进一步的例子: 12345678910111213141516171819202122232425262728293031323334document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听 //希望等待一秒后变化 setTimeout(function(){ console.log(this); //why! 指向window???? 因为这里发生函数调用,则重新绑定,而setTimeout不是被别人调用的,所以是window this.innerHTML = \"clicked\"; })})--------解决方法 一:保存临时this (很乱)-------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); var tmpthis = this; setTimeout(function(){ console.log(tmpthis); tmpthis.innerHTML = \"clicked\"; })}) --------最好的方法: 箭头函数替代--------------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); setTimeout(()=&gt;{ console.log(this); this.innerHTML = \"clicked\"; })}) ==待突破的难点:== ==this 的值是什么?== 12345const ages =[14,19,21];ages.map(age=&gt; \"his age is \"+age );ages.filter(age=&gt; age&gt;18); set123456789101112const numSet = new Set();numSet.add(e) //返回setnumSet.delete(e) //返回boolnumSet.has(e) //返回boolnumSet.size //数组才是length//遍历 或者for of (原本的for in)numSet.forEach(number=&gt; console.log(number)) map123456789101112131415161718const person = new Map();person.set(\"name\",\"laobi\")person.set(\"age\",18) //value可以是不同类型的person.get(\"name\") //返回valueperson.size //数组才是length person.has(\"name\") //返回bool//添加重复的key呢?person.set(\"name\",\"xiaocai\") //将会替换原本的valueperson.delete(\"age\") //返回bool//遍历 或者for of (原本的for in)person.forEach(箭头函数)","link":"/2020/07/30/Arrow%20Func%20&%20set%20map/"},{"title":"Todo-List","text":"一个简单的利用JQuery实现+CSS修饰的静态网页备忘录. 成品 技术重点 JQuery对click, keypress事件的监听 复习bootstrap与css 技术难点 onclick只能对已经存在的元素监听 解决方案: 1234//$(\"li\").on(\"click\",function(){ //尽管使用on,但是还是没法应用到新的li中,因为$(li)绑定行为一开始就执行了,此时只有三个li.$(\"ul\").on(\"click\",\"li\",function(){ //而绑定ul之后, 在click时,再去确认click是其中的哪个li,则可以解决该问题.即$()中的元素一定一开始就要存在,因此此类问题绑定其父节点即可 $(this).toggleClass(\"finished\");}) span元素存在于ul元素中, 点击span会触发ul的监听执行函数 解决方案: e.stopPropagation(); 中断回调传递 1234567//remove evert when click X before it$(\"ul\").on(\"click\",\"span\",function(e){ $(this).parent().fadeOut(function(){ $(this).remove(); //此处使用this,而不是parent,因为已经在fadeOut中,此时this已经指向parent }); //parent()方法返回父元素 e.stopPropagation(); //span处于li,ul,body中,则事件e可能导致其他回调函数,终止传播函数stopPropagation由jQuery提供}) JS代码对html内容的影响 解决方案:$(“ul”).append()函数, 为ul增加item 12345678$(\"input\").on(\"keypress\",function(e){ if(e.which == 13){ let newevent = $(this).val(); $(this).val(\"\"); //清空输入栏 $(\"ul\").append(\"&lt;li&gt;&lt;span&gt;&lt;i class=\\\"fa fa-trash\\\" aria-hidden=\\\"true\\\"&gt;&lt;/i&gt; &lt;/span&gt;\"+newevent+\"&lt;/li&gt;\"); }}) 如何设计hover滑动淡出淡入特效, 需要结合css和JQuery 12345678910111213span{ transition: 0.3s linear; height: 35px; width: 0; opacity: 0; /*设置能见度,优化显示*/}/*有意思的写法 表示hover的li里面的span*/li:hover span{ width: 35px; opacity: 1.0;} 关于fadeout之后remove的研究 123456789//effect 部分$(\"button\").on(\"click\",function(){ $(\"div\").fadeOut(1000,function(){//fade的同时执行函数 //fade只是隐藏显示,在html中仍然存在 //$(this).remove 从html中删除 }); $(\"div\").remove();//不妥,参考setInterval事件队列,fade未执行完成就删除了 })","link":"/2020/07/28/todolist/"}],"tags":[{"name":"ES6特性","slug":"ES6特性","link":"/tags/ES6%E7%89%B9%E6%80%A7/"},{"name":"LC 易错 JS_basis","slug":"LC-易错-JS-basis","link":"/tags/LC-%E6%98%93%E9%94%99-JS-basis/"}],"categories":[{"name":"闲谈","slug":"闲谈","link":"/categories/%E9%97%B2%E8%B0%88/"},{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"},{"name":"JS","slug":"JS","link":"/categories/JS/"}]}