{"pages":[],"posts":[{"title":"Beginning of Everything 起点","text":"“hust&gt; rm -rf”, 了结过往, 面向未来, 是我为HUST计算机学院设计的毕业衫图案 2020年, 没有想象中美好的毕业仪式, 大学四年生活匆匆收场. 本以为最最美好的”大学四年级”结果却是如此孤独寂寥, 假如不是这场疫情所致, 也许现在我已经做好了去美国留学的打算. 在家颓靡的这几个月, 美其名曰”韬光养晦”, 其实也只是浑浑噩噩. 现已是7月底, 大家纷纷找了实习, 而我却迟迟没有迈出这一步. 既然人生这么多遗憾, 为什么不记录下那些美好的时刻呢? 于是乎, 我建立起这个博客, 意在记录那些学习技术过程中的快乐时光. 正如我博客的slogan所言 “have fun with tech“ , 学习技术的过程本身就是一种快乐, 正如男孩学会了积木的拼接, 进而用乐高创造出属于自己的快乐世界. 我也希望在学习的过程中, 记录这些创造性的快乐时刻, 与你们分享技术的乐趣. Go! Go! Xinyuan, explore the Tech &amp; have Fun ! :sparkling_heart:","link":"/2020/07/28/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"},{"title":"This, Call, Aplly, Bind.","text":"在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数中的this指向。 bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 this的理解一个易错点: 123456function a(){ var user = \"xinyuan\"; console.log(this.user); //undefined console.log(this); //Window}a(); 按照我们上面说的this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，等价于window.a(); why?call,apply,bind干什么的？为什么要学这个？ 一般用来指定this的环境，在没有学之前，通常会有这些问题。 123456789var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); }}var b = a.fn; //b获取了a.fn的方法内容,但是this只有被调用的时候才会被确定b(); //undefined 想打印对象a里面的user却打印出来undefined? 其实也就是windows在调用a.fn(); //xinyuan what?1、call() 语法: someObj.call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 将someObj的this指针修改为thisObj对象. 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;b.call(a); call方法除了第一个参数以外还可以添加多个参数，如下： 123456789var a = { user:&quot;xinyuan&quot;, fn:function(e,ee){ console.log(this.user); //xinyuan console.log(e+ee); //3 }}var b = a.fn;b.call(a,1,2); 2、apply() apply方法和call方法有些相似，它也可以改变this的指向 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;b.apply(a); 同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组，如下： 123456789var a = { user:\"xinyuan\", fn:function(e,ee){ console.log(this.user); //xinyuan console.log(e+ee); //11 }}var b = a.fn;b.apply(a,[10,1]); 注意如果call和apply的第一个参数写的是null，那么this指向的是window对象 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this); //Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…} }}var b = a.fn;b.apply(null); 3、bind() bind方法返回的是一个修改过后的函数。 123456789var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;var c = b.bind(a);c(); //xinyuan ok，同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。 12345678910var a = { user:\"xinyuan\", fn:function(e,d,f){ console.log(this.user); //xinyuan console.log(e,d,f); //10 1 2 }}var b = a.fn;var c = b.bind(a,10);c(1,2); 总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。 Application（2） 12345678910111213141516function Animal(){ this.name=\"animal\"; this.showName=function(){ console.log(this.name); } } function Dog(){ this.name=\"dog\"; } var animal=new Animal(); var dog=new Dog(); //animal.showName() 对应\"animal\"animal.showName.call(dog);//输出：dog 在上面的代码中，我们可以看到Dog里并没有showName方法，那为什么（this.name）的值是dog呢？ 关键就在于最后一段代码（animal.showName.call(dog)），意思是把animal的方法放到dog上执行，也可以说，把animal 的showName()方法放到 dog上来执行，所以this.name 应该是 dog。 （3）继承 12345678910111213function Animal(name){ this.name=name; this.showName=function(){ console.log(this.name); } } function Dog(name){ Animal.call(this,name); } var dog=new Dog(\"Crazy dog\"); dog.showName();输出：Crazy dog Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么Dog就能直接调用Animal的所有属性和方法。","link":"/2020/08/17/This,%20Call,%20Aplly,%20Bind/"},{"title":"Quick Sort &amp; Merge Sort","text":"快速排序 和 归并排序 都是采用分治法（Divide and Conquer）的非常典型的应用。 Quick Sort vs Merge Sort快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法, 是采用分治法（Divide and Conquer）的一个非常典型的应用。 归并排序的实现由两种方法： 自上而下的递归 recursion（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代 iteration； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 具体实现快排总体逻辑: 12345678910111213function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) { partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); } return arr;} partition实现: 123456789101112function partition(arr, left ,right) { // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) { if (arr[i] &lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index-1;} 归并排序recursion实现: 123456789101112131415161718192021function merge(leftArr, rightArr){ var result = []; while (leftArr.length &gt; 0 &amp;&amp; rightArr.length &gt; 0){ if (leftArr[0] &lt; rightArr[0]) result.push(leftArr.shift()); //把最小的最先取出，放到结果集中 else result.push(rightArr.shift()); } return result.concat(leftArr).concat(rightArr); //剩下的就是合并，这样就排好序了 } function mergeSort(array){ if (array.length == 1) return array; var middle = Math.floor(array.length / 2); //求出中点 var left = array.slice(0, middle); //分割数组 var right = array.slice(middle); return merge(mergeSort(left), mergeSort(right)); //递归合并与排序 } var arr = mergeSort([32,12,56,78,76,45,36]);console.log(arr); // [12, 32, 36, 45, 56, 76, 78] iteration实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function mergeSort(arr){ if(arr.length&lt;2){ return; } //设置子序列的大小 var step=1; var left,right; while(step&lt;arr.length){ left=0; right=step; while(right+step&lt;=arr.length){ mergeArrays(arr,left,left+step,right,right+step); left=right+step; right=left+step; } if(right&lt;arr.length){ mergeArrays(arr,left,left+step,right,arr.length); } step*=2; } return arr;}//对左右序列进行排序function mergeArrays(arr,startLeft,stopLeft,startRight,stopRight){ // 建立一个左、右数组 var rightArr=new Array(stopRight-startRight+1); var leftArr=new Array(stopLeft-startLeft+1); // 给右数组赋值 k=startRight; for(var i=0;i&lt;(rightArr.length-1);++i){ rightArr[i]=arr[k]; ++k; } // 给左数组赋值 k=startLeft; for(var i=0;i&lt;(leftArr.length-1);++i){ leftArr[i]=arr[k]; ++k; } //设置哨兵值，当左子列或右子列读取到最后一位时，即Infinity，可以让另一个剩下的列中的值直接插入到数组中 rightArr[rightArr.length-1]=Infinity; leftArr[leftArr.length-1]=Infinity; var m=0; var n=0; // 比较左子列和右子列第一个值的大小，小的先填入数组，接着再进行比较 for(var k=startLeft;k&lt;stopRight;++k){ if(leftArr[m]&lt;=rightArr[n]){ arr[k]=leftArr[m]; m++; } else{ arr[k]=rightArr[n]; n++; } }}// 测试数据var nums=[6,10,1,9,4,8,2,7,3,5];console.log(mergeSort(nums)); 疑问 空间复杂度如何分析!!!! 与朱博抡交流得知: 对于快排, 尽管每次quicksort都只使用常量, 但一共log(n)轮累积计算, 空间复杂度为O(log n).","link":"/2020/08/16/Quick%20Sort%20&%20Merge%20Sort/"},{"title":"GundamFans V1.4","text":"更新: route refactoring: 将各类别route封装在不同模块中 data association: 增加user, comment 数据关联 准备秋招, 未完待续… route refactoring1234let express = require(\"express\");let router = express.Router(); //使用router替代app//...module.exports = router; 12commentRouter = require(\"./routes/comment\"),app.use(commentRouter); 注意require时的路径问题! 用户权限设计只有登录状态可以进行: 增加评论(自动记录评论用户名) 增加新的机体信息 非登录状态可以进行: 浏览机体信息 设计思路: 对get&amp;post route均进行限制, 仅响应登录状态的request. 增加user 与 comment 的数据关联修改设计comment model 中的author属性: 1234author: { id:{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }, //对应User model的唯一标志_id username: String, //由于经常使用,所以专门提取出来 }, 修改在route中create comment的步骤: 12345let newcomment = { text: req.body.comText, author:{id:req.user._id, username: req.user.username } }comment.create(newcomment,...","link":"/2020/08/14/GundamFansV1.4/"},{"title":"GundamFans V1.3","text":"更新: 增加authentication 依赖库安装123npm i passportnpm i passport-localnpm i passport-local-mongoose UserSchema设计123456789101112let mongoose = require(&quot;mongoose&quot;);let passportLocalMongoose = require(&quot;passport-local-mongoose&quot;);let UserSchema = new mongoose.Schema({ username: String, password: String});//为User植入authentication各种方法UserSchema.plugin(passportLocalMongoose);module.exports = mongoose.model(&quot;User&quot;,UserSchema); 值得注意的是, UserSchema中的属性名称必须为username和password passport config12345678910app.use(require(&quot;express-session&quot;)({ secret: &quot;My favorite gundam is exia!&quot;, resave: false, saveUninitialized: false,}));app.use(passport.initialize());app.use(passport.session());passport.use(new LocalStrategy(User.authenticate()));passport.serializeUser(User.serializeUser());passport.deserializeUser(User.deserializeUser()); Routes设计register设计: 12345678910111213141516171819202122232425//===============//AUTH ROUTES//===============//show register formapp.get(&quot;/register&quot;,function(req,res){ res.render(&quot;register&quot;);})//handle sign up requestapp.post(&quot;/register&quot;,function(req,res){ let newUser = new User({username: req.body.username}); //form与User中必须定义为username User.register(newUser, req.body.password, function(err, user){ if(err){ console.log(err); res.render(&quot;register&quot;); } else { //验证登录 passport.authenticate(&quot;local&quot;, { successRedirect: '/wiki', failureRedirect: '/register', })(req, res, function(){ }) } })}) 在 register form中设计表项name 也必须为”username” “password”对应. login设计: 12345678910111213//show login formapp.get(&quot;/login&quot;,function(req,res){ res.render(&quot;login&quot;);})//handle login request//app.post(&quot;login&quot;, middleware, callback)app.post(&quot;/login&quot;,passport.authenticate(&quot;local&quot;, { successRedirect: '/wiki', failureRedirect: '/login', }), function(req,res){}) 处于middleware的函数会被立即执行. passport.authenticate直接根据login form中的username 和 password 判断能否登录. 加密页面设置设计函数isLoggedIn()如下: 123456function isLoggedIn(req,res,next){ if(req.isAuthenticated()){ return next();//继续执行后续代码(下一个函数) } res.redirect(&quot;/login&quot;);} 将该函数当做middleware function传入需要登录的页面对应的routes, 即可实现进入该页面前验证登录状态功能. 如: 需要用户登录之后才可以使用评论功能: 1app.get(&quot;/wiki/:id/comment/new&quot;,isLoggedIn ,function(req,res){ 页面元素响应用户状态为了实现页面根据用户状态不同而现实不同内容, 则需要将user信息传入对应route, 在express route中天然req.user即是用户信息结构体, 包含username, _id信息. 可以以参数形式传入: 1res.render(&quot;index&quot;,{User: req.user}); 对于实现navbar随着用户状态而选择显示”Login”或”Logout”的功能, 需要在每个页面中都传入req.user数据. 为了简便, 可以使用app.use()功能, 该功能将参数函数当做middleware, 在每个route执行前运行, res.locals.currentUser设置res本地变量供ejs直接使用. 1234app.use(function(req,res,next){ res.locals.currentUser = req.user; next();}); 易错点 定义UserSchema时属性必须为username, password. ejs的form中, 对应input的name也必须为username, password. bootstrap 4 的navbar需要靠右排列时, 使用.ml-auto类. navbar toggle dont work -&gt; include JQuery!!!","link":"/2020/08/13/GundamFansV1.3/"},{"title":"GundamFans V1.2","text":"更新: Comment模块设计: Data Association in Mongoose, 为了安全性使用expressSanitizer Code Refactoring: 划分module, RESTful routing, seedDB()函数生成初试测试数据 RESTful routesRESTful routes 是一种约定俗成的router定义方式, 对应CURD(Create, Update, Read, Delete)的需求, 设计方式如下: HTTP VERB ROUTE Action Used For GET ‘/wiki’ index action index page to display all gundam info GET ‘/wiki/new’ new action displays create gundam info form POST ‘/wiki’ create action creates one gundam GET ‘/wiki/:id’ show action displays one gundambased on ID in the url GET ‘/wiki/:id/edit’ edit action displays edit form based on ID in the url PUT ‘/wiki/:id’ update action replaces an existing article based on ID in the url DELETE ‘/wiki/:id’ delete action deletes one article based on ID in the url PATCH ‘/wiki/:id’ update action modifies an existing article based on ID in the url Comment Module模式设计12345678910let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: {type:String, default:\"Not available\"}, comments: [{ type: mongoose.Schema.Types.ObjectId, ref: 'comment' }] //一个机体可以有多条评价,“`ref`”告知模式分配哪个模型给该字段。});let commentSchema = new mongoose.Schema({ author: String, text: String,}); 读入数据时, 使用populate方法将 id 替换为实际数据: 1234567891011gundamMS.findById(req.params.id) //搜索结果为json的集合 .populate('comments')// 使用作者 id 填充实际作者信息 .exec(function(err,findms){//exec使用回调函数 if(err){ console.log(err); } else { console.log(findms); res.render(\"show\",{ms:findms}); } });//使用时comments对象由id的数组,变为结构体的数组 安全性expressSanitizer为了使评论格式多样, 在show页面的ejs中, 使用&lt;%- %&gt;进行显示输出, 为了避免用户输入&lt;script&gt;&lt;/script&gt;导致执行恶意代码, 使用expressSanitized: 12345678npm i express-sanitizedlet expressSanitized = require(\"express-sanitized\");app.use(bodyparser.urlencoded({extended:true}));app.use(expressSanitized());//bodyparser之后//&lt;script&gt;alert(\"you have been hacked\")&lt;/script&gt;//&lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒消除script部分 data association in mongoose知识补充模式声明时, 属性可以包含其他模式. 1234567891011121314//模式定义const schema = new Schema({ name: String, binary: Buffer, living: Boolean, updated: { type: Date, default: Date.now }, age: { type: Number, min: 18, max: 65, required: true }, mixed: Schema.Types.Mixed, _someId: Schema.Types.ObjectId, //其他模式 array: [], ofString: [String], // 其他类型也可使用数组 nested: { stuff: { type: String, lowercase: true, trim: true } }}) ObjectId：表示数据库中某一模型的特定实例。例如，一本书可能会使用它来表示其作者对象。它实际只包含指定对象的唯一 ID（_id） 。可以使用 populate() 方法在需要时提取相关信息。 Code Refactoring将schema分到单独的文件, 使用module.exports =..来设置出口变量. 同时设计seedDB()函数为数据库增加原始数据. 注意 :为了保证操作的运行次序, 必须把存在先后次序的操作放在call back中. 1234567891011121314151617181920212223242526272829303132function seedDB(){ //remove all gundamMS.remove({},function(err){ if(err){ console.log(err); } else { console.log(\"removed all MS\"); //add MS data.forEach(function(e){ gundamMS.create(e,function(err,newms){ if(err){ console.log(err); } else { console.log(e); comment.create({ author: \"TOM\", text: \"I love this gundam!!!!!\" }, function(err,newcomment){ if(err){ console.log(err); } else{ newms.comments.push(newcomment); newms.save(); } } ) } }) }) } });}","link":"/2020/08/11/GundamFansV1.2/"},{"title":"GundamFans V1.1","text":"GundamFans意在建立一个高达动漫同好分享网站, 分享自己喜爱的高达机体. 后端主体为nodeJS的express框架, 数据库采用mongoDB, 使用mongoose库进行操作. 前端部分使用ejs来编写网页, 使用bootstrap进行装饰, 具有较好的整合性. 主体文件文件树结构: D:.│ index.js│ package-lock.json│ package.json ├───public //需要app.use(express.static(“public”));指示express来serve public目录│ global.css //全局css设置│└───views //express 默认文件夹 │ index.ejs │ landing.ejs │ newms.ejs │ show.ejs │ └───partials //公用代码 header.ejs tail.ejs ├───node_modules(略) 关键点 框架与库的区别 &lt;%- include(“partials/header”) %&gt;实现头尾部ejs代码公用 post指令无法直接解析req.body.param, 需要body-parser库 ejs中&lt;% %&gt;为逻辑代码不显示, &lt;%= %&gt;为显示代码, &lt;%- %&gt;显示且作为html运行? &lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒 代码逻辑首先在本地开启mongoDB, mongod npm库依赖: 123456const { render } = require(\"ejs\");let express = require(\"express\"), app = express(), bodyparser = require(\"body-parser\"); mongoose = require(\"mongoose\"); 相关设置与端口监听: 123456789//指示express来serve public目录app.use(express.static(\"public\"));// 设置使得body自动被parse,可以直接使用req.body.nameapp.use(bodyparser.urlencoded({extended:true}));//默认使用ejs解析views内容app.set(\"view engine\",\"ejs\");app.listen(3000,function(){ console.log(\"gundam runnig\");}) 连接mongoDB, mongoose.connect(&quot;mongodb://localhost:27017/gundam_fans&quot;,{useUnifiedTopology: true,useNewUrlParser: true }); 构建机体视图schema, 构建模型变量. 123456let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: String});let gundamMS = mongoose.model(\"gundamMS\",gundamMSSchema); Router设计: url HTTP verb purpose 对应ejs / get 加载Landing Page landing /wiki get 展示所有机体信息 index /wiki post 根据页面body表单信息创建机体, redirect(“/wiki”) - /wiki/new get 加载机体创建表格, &lt; form action=”/wiki” method=”POST” &gt; newms /wiki/:id get 加载id对应机体详情页 show 具体实现: /wiki get 实现 1234567891011app.get(\"/wiki\",function(req,res){ //获取所有ms信息 //find() gundamMS.find({},function(err,mslist){ if(err){ console.log(err); } else { res.render(\"index\",{mslist: mslist}); } })}) 搜索结果mslist, 传入index页, 取出单个结构即为gundamMSSchema, 多了一个”_id”属性. e.name等属性直接显示, e_id作为参数传入链接MoreInfo. a href=&quot;/wiki/&lt;%= e._id%&gt;&quot; 通过点击MoreInfo, 进入机体详情页: 123456789101112//显示更多机体信息app.get(\"/wiki/:id\",function(req,res){ //index中的btn link包含_id,利用_id去获取description,(req.params.id获取域名中的参数) gundamMS.findById(req.params.id,function(err,findms){ if(err){ console.log(err); } else { res.render(\"show\",{ms:findms}); } }) }) 对于url中带有的参数:id使用 req.params.id进行访问. 新建机体信息的设置: 首先是在wiki/new下rendernewms页面, 在该页面下提供form. 该表格将信息以POST报文的形式传给/wiki页面. 1234567891011121314&lt;form action=\"/wiki\" method=\"POST\" &gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"msname\" placeholder=\"MS name\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"msimg\" placeholder=\"MS picture url\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"description\" placeholder=\"MS description\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-block\"&gt;GO!&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; /wiki对POST报文进行响应: 12345678910111213141516app.post(\"/wiki\",function(req,res){ let newms = { name:req.body.msname, img:req.body.msimg, description:req.body.description, } gundamMS.create(newms,function(err,newlycreated){ if(err){ console.log(err); } else { res.redirect(\"/wiki\"); } }) }) 其中注意页面信息由req.body.msname获取, 注意此处需要提前引入bodyparser依赖: 123bodyparser = require(\"body-parser\");// 设置使得body自动被parse,可以直接使用req.body.nameapp.use(bodyparser.urlencoded({extended:true})); MongoDB使用整理:首先在本地开启mongoDB, mongod 连接mongoDB, mongoose.connect(&quot;mongodb://localhost:27017/gundam_fans&quot;,{useUnifiedTopology: true,useNewUrlParser: true }); 构建机体视图schema, 构建模型变量. 1234567let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: String});// 使用模式“编译”模型let gundamMS = mongoose.model(\"gundamMS\",gundamMSSchema); 第一个参数是为模型所创建集合的别名（Mongoose 将为 SomeModel 模型创建数据库集合），第二个参数是创建模型时使用的模式。 创建和修改文档插入新数据操作: 123456789101112gundamMS.create( {name:\"ASW-G-08 Gundam Barbatos\", img:\"...\", description:\"...\" },function(err,ms){ if(err){ console.log(err); } else{ console.log(ms); }}); 或使用save(): 123456789// 创建一个 SomeModel 模型的实例const awesome_instance = new SomeModel({ name: '牛人' });// 传递回调以保存这个新建的模型实例awesome_instance.save( function (err) { if (err) { return handleError(err); } // 已保存}); 可以使用“圆点”加字段名来访问、修改新记录中的字段。修改后必须调用 save() 或 update() 以将改动保存回数据库。 12345678910// 使用圆点来访问模型的字段值console.log(awesome_instance.name); // 控制台将显示 '也是牛人'// 修改字段内容并调用 save() 以修改记录awesome_instance.name = \"酷毙了的牛人\";awesome_instance.save( function(err) { if (err) { return handleError(err); } // 已保存}); 搜索纪录 findById()：用指定 id 查找文档（每个文档都有一个唯一 id）。 findOne()：查找与指定条件匹配的第一个文档。 findByIdAndRemove()、findByIdAndUpdate()、findOneAndRemove()、 findOneAndUpdate()：通过 id 或条件查找单个文档，并进行更新或删除。以上是更新和删除记录的便利函数。 查找获取list of elements: 1234567gundamMS.find({},function(err,mslist){ if(err){ console.log(err); } else { console.log(mslist); } }) 查找获取单个element: 1234567gundamMS.findById(req.params.id,function(err,findms){ if(err){ console.log(err); } else { res.render(\"show\",{ms:findms}); }}) 进阶: 以下代码展示了如何在数据库中找到所有网球运动员，并返回运动员姓名和年龄字段。 123456789101112const Athlete = mongoose.model('Athlete', yourSchema);// SELECT name, age FROM Athlete WHERE sport='Tennis'Athlete.find( { 'sport': 'Tennis' }, 'name age', function (err, athletes) { if (err) { return handleError(err); } // 'athletes' 中保存一个符合条件的运动员的列表 }); 若像上述代码那样指定回调，则查询将立即执行。搜索完成后将调用回调。 若未指定回调，则 API 将返回 Query 类型的变量。可以使用该查询对象来构建查询，随后使用 exec() 方法执行（使用回调）。 12345678910111213141516171819202122232425262728// 寻找所有网球运动员const query = Athlete.find({ 'sport': 'Tennis' });// 查找 name, age 两个字段query.select('name age');// 只查找前 5 条记录query.limit(5);// 按年龄排序query.sort({ age: -1 });// 以后某个时间运行该查询query.exec(function (err, athletes) { if (err) { return handleError(err); } // athletes 中保存网球运动员列表，按年龄排序，共 5 条记录})//等价于Athlete. find(). where('sport').equals('Tennis'). where('age').gt(17).lt(50). // 附加 WHERE 查询 limit(5). sort({ age: -1 }). select('name age'). exec(callback); // 回调函数的名字是 callback 查询还能做更多。请参阅 查询（Mongoose 英文文档） 公用html代码header部分 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;I'm Gundam!!!&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"/global.css\"&gt; &lt;/head&gt; &lt;!-- 设计navbar --&gt; &lt;body&gt; tail部分 123&lt;p class=\"text-center\"&gt;Copyright: XinyuanCai.07/2020&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 升级req.body.blog blog[name] blog[img] npm i express-sanitizer 1234567891011form action: /xx/_id?method=PUT method=\"POST\"let expressSanitizer = require(\"express-sanitizer\");let methodOverride = require(\"method-override\");//after bodyparserapp.use(expressSanitizer())app.use(methodOverride(\"_method\"))// 博客的content 我们支持html格式,则...//&lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒消除script部分","link":"/2020/08/07/GundamFansV1.1/"},{"title":"Tree BFS DFS","text":"使用callback以及call技术, 写出标准化的BFS,DFS. 以及扩展性极强的contain. Tree基本数据结构: 12345678910//JS treefunction Node(data){ this.data = data; this. parent = null; this.children = [];}function Tree(data){ this.root = new Node(data);} recurse DFS: 1234567891011Tree.prototype.traverseDF = function(callback){ ( function recurse(currNode){ let length = currNode.children.length; callback(currNode);//先序遍历 for(let i = 0; i&lt;length; i++){ recurse(currNode.children[i]); //当只有两个children时,插在中间则为中序遍历 } //callback(currNode);//后序遍历 } )(this._root);}; 立即使用树的根节点作为其参数调用recurse。 此时，currentNode指向当前节点。 进入for循环并且从第一个子节点开始，每一个子节点都迭代一次currentNode函数。 在for循环体内，使用currentNode的子元素调用递归。 确切的子节点取决于当前for循环的当前迭代。 当currentNode不存在子节点时，我们退出for循环并callback我们在调用traverseDF（callback）期间传递的回调。 queue BFS: 1234567891011121314//queue BFSTree.prototype.traverseBF = function(callback){ let queue = []; queue.push(this._root); let currNode = queue.shift(); while(currNode){ let length = currNode.children.length; for(let i = 0; i&lt;length; i++){ queue.push(currNode.children[i]); } callback(currNode); currNode = queue.shift(); }} 创建 Queue的实例。 将调用traverseBF(callback)的节点添加到Queue的实例。 定义一个变量currentNode并且将他的值初始化为刚才添加到队列里的node 当currentNode指向一个节点时，执行wille循环里面的代码。 用for循环去迭代currentNode的子节点。 在for循环体内，将每个子元素加入队列。 获取currentNode并将其作为callback的参数传递。 将currentNode重新分配给正从队列中删除的节点。 直到currentNode不在指向任何节点-也就是说树中的每个节点都访问过了-重复4-8步。 自定义的contain contains(callback, traversal)接收两个参数：搜索的数据和遍历的类型。 123Tree.prototype.contains = function(callback, traversal) { traversal.call(this, callback);}; 使用示例： 123456// tree is an example of a root nodetree.contains(function(node){ if (node.data === 'two') { console.log(node); }}, tree.traverseBF); 深度优先遍历问题二叉树的所有路径-257 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 123456789101112输入: 1 / \\2 3 \\ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3复制代码 来源：力扣（LeetCode） 链接：leetcode-cn.com/problems/bi… 路径(n)为当前node, 与路径(n.left)和路径(n.right)的拼接. 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {string[]} */var binaryTreePaths = function(root) { let res = []; if(!root){return res}; if((!root.left)&amp;&amp;(!root.right)){return [root.val]}; let left_result = binaryTreePaths(root.left); let right_result = binaryTreePaths(root.right); left_result.forEach(e =&gt;{ res.push(root.val+&quot;-&gt;&quot;+e); }); right_result.forEach(e =&gt;{ res.push(root.val+&quot;-&gt;&quot;+e); }); return res;}; 广度优先遍历（BFS）问题在每个树行中找最大值-515 leetcode-cn.com/problems/fi… 您需要在二叉树的每一行中找到最大的值。 1234567891011输入: 1 / \\ 3 2 / \\ \\ 5 3 9输出: [1, 3, 9]复制代码","link":"/2020/08/04/Tree%20BFS%20DFS/"},{"title":"LC_training(2)","text":"易错点 forEach()函数体中,无法使用return终止运行,也不能使用break,continue. 应该使用其他语法. 123456MyHashSet.prototype.contains = function(key) { this.set.forEach(function(e){ if(e == key) return true; }); return false;}; 今天遇到一个还挺厉害的简单题解法: 有效的括号-20 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。其实就是栈问题.leetcode-cn.com/problems/va… 常规写法: 略 进阶写法: 12345678910111213141516171819202122232425var isValid = function(s) { let map = { \"{\":\"}\", \"(\":\")\", \"[\":\"]\" }; var stack = []; let len = s.length; let top = \"\"; for (let char of s){ //char of s将s当做一个数组??如何办到的 if (map[char]) { //利用map取代一个个判断条件 stack.push(char); top = char; } else { if(char == map[top]){ //利用map构建对应关系 stack.pop(); top = stack[stack.length-1]; } else return false; } } return !stack.length; //return的条件简化};","link":"/2020/08/02/LeetCode%E5%BF%83%E5%BE%97(2)/"},{"title":"LinkedList basis","text":"简单的链表训练 链表基本实现:12345678910111213141516171819202122232425262728293031323334353637//结点的构造函数function Node(e){ this.e = e; this.next = null;}//搜索item元素所在nodefunction find (item){ let currNode = this.head; while(currNode.e!=item){ currNode = currNode.next; } return currNode;}//在item元素之前插入newelementfunction insert (newElement,item){ let newNode = new Node(newElement); let target = this.find(item); newNode.next= target.next; target.next = newNode;}function display(){ let currNode = this.head; while(currNode){ console.log(currNode.e); currNode = currNode.next; }}//链表的构造函数function LList() { this.head = new Node('head');//头结点 this.find = find; //定义函数? this.insert = insert; this.display = display;} 典型例题:两两交换链表中的节点-24 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 12给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.复制代码 来源：力扣（LeetCode） 链接：leetcode-cn.com/problems/sw… 1234567891011121314//实现对链表两个节点的交换function switchwithnext(node){ if(!node) return null; let nextnode = node.next; if(!nextnode) return node; node.next = switchwithnext(nextnode.next); nextnode.next = node; return nextnode;}function solution(head){ let res = switchwithnext(head); return res;} 难吗?还行,重点是next的理解,要画图.","link":"/2020/07/31/LinkedList/"},{"title":"LC_training(1)","text":"犯过的那些错误 一个专属JS的不起眼的坑!!! 1234for(var i in nums){ if(nums[i]==nums[i+1]){ ... } 上述代码中nums[i+1]结果undifined, 因为for in遍历的原理是什么呢? 其实是把nums数组当做Obejct(一个键值对结构), 其中i 是对于其key的遍历, 因此i 其实是字符串”0”, 而i+1则表示”01”, 自然是找不到结果. 对此问题我们深入研究, 123456 const arr = [ “ a”，“ b”，“ c” ]; arr.test = “坏”；//既然数组是object,就可以添加非数字属性 for (let i in arr) { console.log(i+\":\"+ arr[i]); // 打印\"0:a, 1:b, 2:c, test:bad\"} 因此在 Js的数组遍历中,我们应该避免使用for/in, 而可以选择for/of替代. 123456 for (const element of arr) { console.log(element); } for (let i = 0; i &lt; arr.length; ++i) { console.log(arr[i]);} 此外, for，for/in与for/of会保留外部作用域的this。 对于forEach， 除非使用箭头函数，它的回调函数的 this 将会变化。 1234567891011 \"use strict\"; const arr = [\"a\"]; arr.forEach(function() { console.log(this); // 打印undefined }); arr.forEach(() =&gt; { console.log(this); // 打印{}}); JS对象 与 哈希表: js中的对象是基于哈希表结构的,而哈希表的查找时间复杂度为O(1),所以很多人喜欢用对象来做映射,减少遍历循环. 对于找数组重复元素, 我们的核心是利用key存储数据, 利用value来记录该元素是否存在(bool), 但是需要注意的是key值会被转化为字符串, 因此数组中元素类型应该保持一致. 核心: object, 是属性名-属性值的键值对, 对于属性名(字符串)的ASII码进行哈希算法的应用, 这样就构建了高效(O(1)时间存取)的HashMap结构了. 一个很蠢的问题: 123let tmp = nums[i];nums[i] = nums[nums[i]];nums[nums[i]] = tmp; 经常在自身哈希的题目中犯错, nums[i]的值被改变了呀! 应该提前将nums[i]的值保存下来: 12let numi = nums[i];[nums[i],nums[numi]] = [nums[numi],nums[i]]//解构赋值语法ES6 拼写：querySelector,querySelectorAll,addEventListener, querySelectorAll的函数返回为 Nodelist, 千万不要直接使用！！！ 题解 找出数组中重复的数字。长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 排序之后遍历判断相邻元素: nlogn, n var findRepeatNumber = function(nums) { nums.sort(); for(let i=0; i&lt;nums.length;i++){ if(nums[i]==nums[i+1]){ return 9; } } return 0; }; &lt;!--￼6--&gt; 采用基于对象的hash映射, n, n (基于假设set存取均为O(1)): var findRepeatNumber = function(nums) { let obj = {}; for(num of nums){ if(!obj[num]){ obj[num]=true; } else{ return num; } } }; 所有数字都在 0 ～ n-1 的范围内。因此不需要额外开辟空间，每次遍历时，检查当前元素是否放在了正确位置上（例如元素 i 应该放在下标为 i 的位置上）。如果放在了正确位置上，那么继续循环。否则： 下标为 num 的元素 == num，说明当前元素 num 是重复的，直接返回下标为 num 的元素 != num，交换当前元素和下标为 num 的元素，将当前元素放入到正确位置上 n, 1 (基于假设set存取均为O(1)) 二维数组中的查找观察大小规则, 利用单调性查找元素!","link":"/2020/07/30/LeetCode%E5%BF%83%E5%BE%97(1)/"},{"title":"Arrow Func &amp; set map","text":"箭头函数箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 应用场合:普通函数会重新绑定this, 箭头函数不会重新绑定this. 根据需求选择…… 面试经典: 当前this是什么? 举例子: 12345678910111213document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听})-----------------------------------------------------------console.log(this) //输出windowdocument.getElementById(\"the-button\").addEventListener(\"click\",()=&gt;{ console.log(this);//输出的是window this.classList.add(\"bigger\");//添加监听失败}) 原因是箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 这里该函数作为addEventListener的参数, 其实是被button 调用 更进一步的例子: 12345678910111213141516171819202122232425262728293031323334document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听 //希望等待一秒后变化 setTimeout(function(){ console.log(this); //why! 指向window???? 因为这里发生函数调用,则重新绑定,而setTimeout不是被别人调用的,所以是window this.innerHTML = \"clicked\"; })})--------解决方法 一:保存临时this (很乱)-------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); var tmpthis = this; setTimeout(function(){ console.log(tmpthis); tmpthis.innerHTML = \"clicked\"; })}) --------最好的方法: 箭头函数替代--------------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); setTimeout(()=&gt;{ console.log(this); this.innerHTML = \"clicked\"; })}) ==待突破的难点:== ==this 的值是什么?== 12345const ages =[14,19,21];ages.map(age=&gt; \"his age is \"+age );ages.filter(age=&gt; age&gt;18); set123456789101112const numSet = new Set();numSet.add(e) //返回setnumSet.delete(e) //返回boolnumSet.has(e) //返回boolnumSet.size //数组才是length//遍历 或者for of (原本的for in)numSet.forEach(number=&gt; console.log(number)) map123456789101112131415161718const person = new Map();person.set(\"name\",\"laobi\")person.set(\"age\",18) //value可以是不同类型的person.get(\"name\") //返回valueperson.size //数组才是length person.has(\"name\") //返回bool//添加重复的key呢?person.set(\"name\",\"xiaocai\") //将会替换原本的valueperson.delete(\"age\") //返回bool//遍历 或者for of (原本的for in)person.forEach(箭头函数)","link":"/2020/07/30/Arrow%20Func%20&%20set%20map/"},{"title":"Todo-List","text":"一个简单的利用JQuery实现+CSS修饰的静态网页备忘录. 成品 技术重点 JQuery对click, keypress事件的监听 复习bootstrap与css 技术难点 onclick只能对已经存在的元素监听 解决方案: 1234//$(\"li\").on(\"click\",function(){ //尽管使用on,但是还是没法应用到新的li中,因为$(li)绑定行为一开始就执行了,此时只有三个li.$(\"ul\").on(\"click\",\"li\",function(){ //而绑定ul之后, 在click时,再去确认click是其中的哪个li,则可以解决该问题.即$()中的元素一定一开始就要存在,因此此类问题绑定其父节点即可 $(this).toggleClass(\"finished\");}) span元素存在于ul元素中, 点击span会触发ul的监听执行函数 解决方案: e.stopPropagation(); 中断回调传递 1234567//remove evert when click X before it$(\"ul\").on(\"click\",\"span\",function(e){ $(this).parent().fadeOut(function(){ $(this).remove(); //此处使用this,而不是parent,因为已经在fadeOut中,此时this已经指向parent }); //parent()方法返回父元素 e.stopPropagation(); //span处于li,ul,body中,则事件e可能导致其他回调函数,终止传播函数stopPropagation由jQuery提供}) JS代码对html内容的影响 解决方案:$(“ul”).append()函数, 为ul增加item 12345678$(\"input\").on(\"keypress\",function(e){ if(e.which == 13){ let newevent = $(this).val(); $(this).val(\"\"); //清空输入栏 $(\"ul\").append(\"&lt;li&gt;&lt;span&gt;&lt;i class=\\\"fa fa-trash\\\" aria-hidden=\\\"true\\\"&gt;&lt;/i&gt; &lt;/span&gt;\"+newevent+\"&lt;/li&gt;\"); }}) 如何设计hover滑动淡出淡入特效, 需要结合css和JQuery 12345678910111213span{ transition: 0.3s linear; height: 35px; width: 0; opacity: 0; /*设置能见度,优化显示*/}/*有意思的写法 表示hover的li里面的span*/li:hover span{ width: 35px; opacity: 1.0;} 关于fadeout之后remove的研究 123456789//effect 部分$(\"button\").on(\"click\",function(){ $(\"div\").fadeOut(1000,function(){//fade的同时执行函数 //fade只是隐藏显示,在html中仍然存在 //$(this).remove 从html中删除 }); $(\"div\").remove();//不妥,参考setInterval事件队列,fade未执行完成就删除了 })","link":"/2020/07/28/todolist/"}],"tags":[{"name":"ES6特性","slug":"ES6特性","link":"/tags/ES6%E7%89%B9%E6%80%A7/"},{"name":"LC","slug":"LC","link":"/tags/LC/"},{"name":"易错","slug":"易错","link":"/tags/%E6%98%93%E9%94%99/"},{"name":"Full Stack","slug":"Full-Stack","link":"/tags/Full-Stack/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"ejs","slug":"ejs","link":"/tags/ejs/"},{"name":"mongoDB","slug":"mongoDB","link":"/tags/mongoDB/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"Front-End","slug":"Front-End","link":"/tags/Front-End/"},{"name":"JQuery","slug":"JQuery","link":"/tags/JQuery/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"}],"categories":[{"name":"闲谈","slug":"闲谈","link":"/categories/%E9%97%B2%E8%B0%88/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"Application","slug":"Application","link":"/categories/Application/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}]}