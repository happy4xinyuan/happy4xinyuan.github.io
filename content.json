{"pages":[],"posts":[{"title":"Beginning of Everything 起点","text":"“hust&gt; rm -rf”, 了结过往, 面向未来, 是我为HUST计算机学院设计的毕业衫图案 2020年, 没有想象中美好的毕业仪式, 大学四年生活匆匆收场. 本以为最最美好的”大学四年级”结果却是如此孤独寂寥, 假如不是这场疫情所致, 也许现在我已经做好了去美国留学的打算. 在家颓靡的这几个月, 美其名曰”韬光养晦”, 其实也只是浑浑噩噩. 现已是7月底, 大家纷纷找了实习, 而我却迟迟没有迈出这一步. 既然人生这么多遗憾, 为什么不记录下那些美好的时刻呢? 于是乎, 我建立起这个博客, 意在记录那些学习技术过程中的快乐时光. 正如我博客的slogan所言 “have fun with tech“ , 学习技术的过程本身就是一种快乐, 正如男孩学会了积木的拼接, 进而用乐高创造出属于自己的快乐世界. 我也希望在学习的过程中, 记录这些创造性的快乐时刻, 与你们分享技术的乐趣. Go! Go! Xinyuan, explore the Tech &amp; have Fun ! :sparkling_heart:","link":"/2020/07/28/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"},{"title":"react-UI","text":"","link":"/2020/09/04/React-Ui/"},{"title":"react-router路由跳转的方法","text":"1. NavLink or Link略. 区别在于activeClassName的有无 2.自己实现(利用props.history的方法)1&lt;button onClick={()=&gt;this.showDetail(m.id)} className=\"btn btn-primary\"&gt; 对于onClick我们常常使用onClick={this.showDetail}, 然后利用ref指定该部件输入值赋给props属性, 或者使用event对象获取. 为了自由地传入数据, 可以采用以上写法. showDetail 函数实现: 123showDetail = (id) =&gt;{ this.props.history.replace(`/home/message/message-detail/${id}`);} 两者的区别在于, 浏览器回退时的结果不同 123showDetail = (id) =&gt;{ this.props.history.push(`/home/message/message-detail/${id}`);} 3.设计回退与前进(利用props.history的方法)123456forward = () =&gt;{ this.props.history.goForward();}back = () =&gt;{ this.props.history.goBack();} 4. 普通链接的跳转? 常规的就是使用&lt;a href=&quot;&quot;&gt;&lt;/a&gt; JS实现: window.location button绑定函数, 实现如下: 123reqPage = ()=&gt;{ window.location = 'http://www.baidu.com'}","link":"/2020/09/04/%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"练手react-router","text":"基本标签的使用 在index.js中, render的对象需要用&lt;BrowserRouter&gt;包裹: 1234567891011import {BrowserRouter, HashRouter} from 'react-router-dom';ReactDOM.render( ( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; ), document.getElementById('root')); 导航标签: 12import {NavLink, Switch, Route, Redirect}} from \"react-router-dom\";&lt;NavLink to='/about'&gt;About&lt;/NavLink&gt; 切换标签, 路由标签, 重定向标签 12345678{/*可切换的路由组件, 只显示其中一个*/}&lt;Switch&gt; {/*Route组件定义一个映射关系, 将组件与路径url对应*/} &lt;Route path='/about' component={About}/&gt; &lt;Route path='/home' component={Home}/&gt; &lt;Redirect to='/about'/&gt; //表示默认重定向路由&lt;/Switch&gt; 自定义NavLink标签样式官方文档 123&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt; FAQs&lt;/NavLink&gt; 修改activeClassName (该属性表示被激活的NavLink被添加的类名, 默认 为 ‘active’ , 因此被BS4修饰) 接着可以在index.css中对selected对象进行修饰. 对于css多文件修饰对象, 可以在属性中增加!important防止被覆盖! .selected{ color: palevioletred !important; } &lt;!--￼4--&gt; 其中...运算符十分关键, 因为你不知道外部传入了多少个属性, 因此没法在props中一个个声明. 但是可以直接全部展开并传入NavLink中. 1&lt;MyNavLink className=\"list-group-item\" to='/about' &gt;About&lt;/MyNavLink&gt; 嵌套路由没什么难的, 复习一下. 路由的核心: 网页的入口: NavLink to='/home/news' 需要动态显示的部分: &lt;Switch&gt;&lt;/Switch&gt; 网页路径 与 显示部件的映射关系: &lt;Route path='/home/message' component={Message}/&gt; 路由传参 this.props.match.params 路由参数 :paramname 1&lt;Route path='/home/message/message-detail/:id' component={MessageDetail}&gt; 组件取参 this.props.match.params 中包含url中的参数 a href是普通链接, 只有NavLink才是路由链接. 有时候出现点击链接后boostrap样式丢失, 可能是因为点的是普通链接的原因. 小技巧 对数组的find方法, 提供一个判断函数! 1const massage = massages.find((m) =&gt; m.id == id); //匹配第一个未true的数组元素","link":"/2020/09/02/%E7%BB%83%E6%89%8Breact-router/"},{"title":"初识react-router","text":"1. 理解react-routerreact的一个插件库专门用来实现一个SPA应用(single page web application，SPA）基于react的项目基本都会用到此库 2. 几个重要问题1). SPA应用单页Web应用（single page web application，SPA） 整个应用只有一个完整的页面 点击页面中的链接不会刷新页面, 本身也不会向服务器发请求 当点击路由链接时, 只会做页面的局部更新 数据都需要通过ajax请求获取, 并在前端异步展现 2). 路由 什么是路由? 一个路由就是一个映射关系(key:value)key为路由路径, value可能是function/component 路由分类 后台路由: node服务器端路由, value是function, 用来处理客户端提交的请求并返回一个响应数据 前台路由: 浏览器端路由, value是component, 当请求的是路由path时, 浏览器端前没有发送http请求, 但界面会更新显示对应的组件 后台路由 注册路由: router.get(path, function(req, res)) 当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据 前端路由 注册路由:&lt;Route path=&quot;/about&quot; component={About}&gt; 当浏览器的hash变为#about时, 当前路由组件就会变为About组件 3). 关于url中的# 理解#‘#’代表网页中的一个位置。其右面的字符，就是该位置的标识符改变#不触发网页重载改变#会改变浏览器的访问历史 操作#window.location.hash读取#值window.onhashchange = func 监听hash改变 学习资源:阮一峰教程: http://www.ruanyifeng.com/blog/2011/03/url_hash.html 3. react-router的学习资源github主页: https://github.com/ReactTraining/react-router官网教程: https://github.com/reactjs/react-router-tutorial阮一峰教程: http://www.ruanyifeng.com/blog/2016/05/react_router.html 4. 相关API1). react-router中的相关组件:Router: 路由器组件, 用来包含各个路由组件Route: 路由组件, 注册路由IndexRoute: 默认子路由组件hashHistory: 路由的切换由URL的hash变化决定，即URL的#部分发生变化Link: 路由链接组件 2). Router: 路由器组件属性: history={hashHistory} 用来监听浏览器地址栏的变化, 并将URL解析成一个地址对象，供React Router匹配子组件: Route 3). Route: 路由组件属性1: path=”/xxx”属性2: component={Xxx}根路由组件: path=”/“的组件, 一般为App子路由组件: 子配置的组件 4). IndexRoute: 默认路由当父路由被请求时, 默认就会请求此路由组件5). hashHistory用于Router组件的history属性 作用: 为地址url生成?_k=hash, 用于内部保存对应的state6). Link: 路由链接属性1: to=&quot;/xxx&quot; 属性2: activeClassName=&quot;active&quot;5. react-router的基本使用1). 下载npm install react-router --save2). 定义各个路由组件1. About.js import React from &apos;react&apos; function About() { return &lt;div&gt;About组件内容&lt;/div&gt; } export default About 2. Home.js import React from &apos;react&apos; function Home() { return &lt;div&gt;Home组件内容2&lt;/div&gt; } export default Home 3. Repos.js import React, {Component} from &apos;react&apos; export default class Repos extends Component { render() { return ( &lt;div&gt;Repos组件&lt;/div&gt; ) } } 4. App.js import React, {Component} from &apos;react&apos; import {Link} from &apos;react-router&apos; export default class App extends Component { render() { return ( &lt;div&gt; &lt;h2&gt;Hello, React Router!&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About2&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos2&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; {this.props.children} &lt;/div&gt; ) } }3). index.js: 注册路由, 渲染路由器标签import React from &apos;react&apos; import {render} from &apos;react-dom&apos; import {Router, Route, IndexRoute, hashHistory} from &apos;react-router&apos; import App from &apos;./modules/App&apos; import About from &apos;./modules/About&apos; import Repos from &apos;./modules/Repos&apos; import Home from &apos;./modules/Home&apos; render(( &lt;Router history={hashHistory}&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;IndexRoute component={Home}/&gt; &lt;Route path=&quot;/about&quot; component={About}&gt;&lt;/Route&gt; &lt;Route path=&quot;/repos&quot; component={Repos}&gt;&lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt; ), document.getElementById(&apos;app&apos;))3). 主页面: index.html&lt;style&gt; .active { color: red; } &lt;/style&gt;6. 向路由组件传递请求参数","link":"/2020/09/01/%E5%88%9D%E8%AF%86react-router/"},{"title":"组件间通信","text":"方式一: 通过 props 传递1) 共同的数据放在父组件上, 特有的数据放在自己组件内部(state) 2) 通过 props 可以传递一般数据和函数数据, 只能一层一层传递 3) 一般数据–&gt;父to子–&gt;子组件读取数据 新的数据以props出现, 因此在componentWillReceiveProps中编写ajax请求代码 4) 函数数据–&gt;子to父–&gt;子组件调用函数 存在的问题: 孙子组件需要逐层传递 cousin组件需要以父组件作为媒介 props属性只能通过外部接口赋值, state属性只能通过this.setState设置 方式二: 使用消息订阅(subscribe)-发布(publish)机制 很好解决props上述两个问题 订阅相当于绑定, 发布相当于触发. 1) 工具库:PubSubJS 2) 下载:npm install pubsub-js –save (该机制对多种语言都有效, 下载js版本 3) 使用: 12345import PubSub from'pubsub-js'//引入 PubSub.subscribe('delete',function(data){});//订阅 PubSub.publish('delete',data)//发布消息 回调函数最好使用箭头函数 比如在回调函数中使用this.setState报错 利用PubSub可以很方便地实现cousin通信 sub&amp;pub的判断: 在触发事件的地方pub消息 订阅一般发生在componentDidMount中 (对于函数数据, 表面上父to子, 其实是子to父. 因此pubsub可能与直觉相违背) 如父元素中的数据, 由子元素的事件导致改变. 则父元素将会把自身的update函数传给子元素, 由子元素调用. 然而在pubsub中, 应该改写为子元素将事件信息pub, 父元素sub监听, 利用子元素的信息调用update 方式三:redux后面专门讲解","link":"/2020/08/31/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/"},{"title":"实现github用户搜索页面","text":"几个重要实现点: cousin元素之间传递数据麻烦 -&gt; 通过父元素作为中介 数据在哪个组件被使用, 被修改 -&gt; 优先放在该组件中 假如中途触发请求 -&gt; 在页面数据变化(如搜索关键词)发送请求 -&gt; 在componentWillReceiveProps中使用axios发送异步ajax请求 1234567891011121314151617181920212223242526272829303132333435//接受新的属性时,回调componentWillReceiveProps(nextProps, nextContext) { const {SearchName} = nextProps; //更新状态 this.setState({ initView: false, loading: true, }) //发送ajax请求 const url = `https://api.github.com/search/users?q=${SearchName}`; axios.get(url) .then(res =&gt; { //请求成功,处理 console.log(res); const data = res.data; const users = data.items.map(e =&gt; ( { url: e.html_url, avatarUrl: e.avatar_url, name: e.login } ) ); this.setState({ loading: false, users: users }); }) .catch(error =&gt; { this.setState({ initView: true, errorMsg: error, }) });}","link":"/2020/08/31/github%E7%94%A8%E6%88%B7%E6%90%9C%E7%B4%A2%E9%A1%B5%E9%9D%A2/"},{"title":"国内外服务器差距","text":"HW，inspur, Lenovo v.s. ??? DELL &amp; HP &amp; IBM(??) 细分硬件平台：CPU GPU 主存 外存 &lt;1&gt;CPU &amp; 主板 申威 &amp; 飞腾 &amp; 龙芯 &amp; ??? v.s. Intel &amp; AMD &amp; ARM &amp; supermicro 中国CPU的发展起步较早，由于中间战略调整错失了和美国齐头并进的机会，目前最自主的CPU基于永久的架构授权，自主设计然后找代工厂生产，但由于代工厂的全球协约同样收到打压，目前看在供应链方面的瓶颈成了新问题。 目前国产起量的CPU有ARM、x86、MIPS和α架构，还有宏芯获得的Power8架构。由于政策、市场、技术等多方面原因，ARM的势头占优，特殊领域基于MIPS的龙芯表现也很不错。 国产cpu发展现状: 按照指令集的复杂程度划分，我们可以把CPU简单划分为两种架构，一类是RISC(精简指令集处理器, 如),另一种是CISC（复杂指令集处理器, 如X86处理器） 按照基础指令集的不同，目前世界上的CPU可以分为五大体系，分别RISC类别的ARM体系、MIPS体系、Power体系、Alpha体系、ARM体系和 CISC类别的X86体系 1. 国内MIPS体系处理器的现状-充满生机与活力 MIPS的意思是“无内部互锁流水级的微处理器”(Microprocessor without interlocked pipedstages)，其机制是尽量利用软件办法避免流水线中的数据相关问题 国内MIPS处理器的代表有两家，一家是大家都经常能听到的龙芯，另一家为君正。 龙芯是2002年由中国科学院计算所开始研发, 第一代产品发布时是没有经过MIPS正式授权的，有侵权的嫌疑, 但龙芯支付了一笔费用永久性获得了MIPS32和MIPS64架构的授权，现在龙芯完全是自主可控的，将来不会再出现被别人卡脖子受限于人的局面。 龙芯经过这么多年的发展也早已不是简单的其他MIPS处理器仿制版，在MIPS固有指令集上龙芯还添加了不少自主研发的指令集，指令集数量是原有两倍。 目前龙芯最新的产品是2019年年底发布的龙芯3A4000 与 3B4000: 3A4000是面向桌面台式机和笔记本，采用28nm打造，4核4线程，主频为1.8~2.0GHz（也就是支持睿频），面向科学计算、高密度数值信息处理的峰值计算性能是上代产品龙芯3A3000的4倍以上，通用处理性能基本打平AMD的末代28nm产品“挖掘机”。 3B4000属于龙芯服务器CPU产品线，在核心线程、频率上与芯3A4000一致，但支持双路、四路服务器，即在一台服务器主板上安装2个或者4个龙芯3B4000芯片，一台服务器最多包含16个处理器核。所有CPU之间通过高速总线接口直接互联，共享使用物理内存。龙芯3B4000专门优化了CPU之间的高速互连总线，跨片访存实际带宽提升400%以上。 目前龙芯的发展势头还是十分不错的，已经不需要国家经费支持，完全实现自给自足，公司收入主要来源为太空芯片销售、高温芯片销售、对外IP授权销售、嵌入式方案销售和党政军采购，在19年年底的发布会上龙芯中科董事长胡伟武表示龙芯在2019年出货量达到50万颗，净利润达上亿元，合作伙伴已经增至近千家，下游基于龙芯的开发人员达到数万人，使用龙芯的笔记本、一体机、服务器、云终端、网络安全设备、工业控制计算机等产品已经运用于我国的各行各业。 国内MIPS处理器虽然发展地不错，但是由于最新的微软Windows系统只支持X86处理器和部分ARM处理器，我们普通人一般是接触不到MIPS处理器，认知不足也可以理解，就算买来龙芯的笔记本，由于生态和软件的问题，对普通人来说也是浪费钱。 2.国内ARM体系处理器的现状-星星之火已成燎原 ARM全称为Advanced RISC Machines（高级RISC核心, 大家手中的手机就是用ARM处理器的，使用32位精简指令集，ARM处理器具有低功耗高性能、大量使用寄存器读取指令快、体积小、指令长度固定、节省存储空间等特点。 ARM处理器也是一个商业化十分成功的处理器，只要你向ARM公司支付一笔费用，就能获得ARM处理器的授权. (授权的模式有三种，第一是架构/指令集层级授权，授权后你可以对ARM架构进行大幅度改造，甚至可以对ARM指令集进行扩展或缩减，比如苹果、华为就是这种；其二是内核层级授权，你可以以一个内核为基础添加其他模块；其三是使用层级授权，意思是你只能使用，不能魔改。) 国内发展ARM处理器体系主要有四家，分别是华为海思、飞腾、展讯。 华为海思应该是国内ARM处理器商业化最成功的公司了。华为海思的处理器主要应用于移动端产品，应用场景包括但不仅限于手机、监控设备、机顶盒、电视和路由器等，最新的代表产品就是麒麟990 5G版了，7nm euv工艺打造，集成5G基带，其CPU性能可与目前世界一流水平的手机处理器骁龙865、A13同台竞技。 华为海思在服务器领域也有涉足，最新产品为鲲鹏920，7nm工艺打造，最高可扩展为64核，主频为2.6GHz，支持8通道DDR4内存和PCIe 4.0。不过鲲鹏920目前还处于华为自用阶段，作为于华为云服务的服务器内核，而且目前高性能服务器基本都是X86处理器的天下，鲲鹏920暂时不会对服务器市场造成多大的影响。 飞腾公司是中国国防科技大学高性能处理器研究团队建立的企业. 一开始飞腾是做逆向工程的, 后来转向做Sparc处理器. 010年国防科大的银河一号超算进行扩容时加入了2048颗FT-1000处理器，虽然相比于超算其他的AMD、Intel处理器数量来说微不足道，但也足以振奋国内研发人员，激发了当时国人的民族自豪感. SPARC架构母公司被Oracle收购之后, 飞腾果断就转向做更火的ARM架构处理器。 飞腾也是购买了ARMv8指令集的永久授权，最新产品2019年9月发布的FT-2000/4处理器，4核4线程，16nm工艺打造，最高主频为3.0GHz，最大功耗仅为10W，主要面向台式机或者笔记本。目前FT-2000/4已和国产银河麒麟操作系统（PC版）完成了全部适配工作，因为不使用Windows系统，主要客户也是军队、政府等单位了。 展讯公司是一个不得不提的国内ARM处理器设计公司，根据统计展讯每年出货6亿片芯片，占据全球手机芯片25%的市场，仅次于高通和联发科，在去年展讯旗下的SC6531芯片击败了高通华为联发科三星成为单芯片出货量世界第一。 手机芯片主要用于老人机、三防手机上，主打耐用性与超长续航，仅支持GSM、GPRS两种网络制式，主要市场也集中于非洲、东南亚等低收入海外市场，是真正走出去的国产芯片。 3.国内Power体系处理器的现状-胎死腹中？Power架构是蓝色巨人IBM开发的指令系统架构，大到超算，小到车载音响都有它的身影。Power价格昂贵.2016年国内企业中昊宏芯获得了POWER 8芯片架构和指令系统的永久授权，但中昊宏芯研发过程并不顺利，期间还遇到股权变更和欠薪事件，国产Power也就一直难产，至今都没有影子。 2019年8月POWER指令集架构正式开源，或许这能促进国产Power处理器出现。 4. 国内Alpha体系处理器的发展-已成独苗Alpha是DEC公司制造的处理器架构，后来DEC公司被美国惠普收购，而惠普的精力主要在“X86架构”的个人电脑，所以对Alpha架构的指令集早已很久没有更新. 恰逢我们国家全力发展自主科技，所以我们无锡的江南计算所（军方研究机构）买了Alpha架构的所有设计资料，制造了完全自主可控的国产Alpha处理器，也就是大名鼎鼎的申威，申威处理器也是目前Alpha架构处理器的独苗了。 江南计算所在原有Alpha指令集的基础上增添了SIMD等特色的扩展指令集，还拓展了多核架构，把Alpha架构处理器发展到新的高度，现在的申威处理器和以前的Alpha处理器已经不可同日而语，最新的申威SW26010处理器使用了申威为高性能计算自主研发的指令集. 此前多次夺得超算排名第一的神威·太湖之光超算就用了多达40960颗申威26010众核处理器，全都是超算的运算主力，并不像飞腾那样打打辅助，由此可知申威26010众核处理器确实实力过硬，能与其他国家的超算一比高下。 5. 国内X86体系处理器的发展-势头良好，仍存阻碍国内要想发展X86处理器，最大的难题是授权问题，在X86处理器发展过程中Intel和AMD的指令集经过复杂的融合，形成了如今两家交叉授权才是完整X86指令集的局面，换句话而言想堂堂正正地发展X86处理器，理论上要同时得到Intel和AMD的授权才行。 兆芯： 目前世界上除了Intel和AMD以外第三家拥有X86授权的公司，是威盛VIA，上海兆芯集成电路有限公司经过一番操作也是取得了威盛VIA X86处理器的授权。早期兆芯处理器也只是威盛处理器简单的仿制产品，不过经过这么多年的迭代研发，兆芯已经研发出KX-6000系列处理器，基于16nm制程，主频可达3GHz，有4核/8核可选，集成核显、支持双通道DDR4内存，性能与Intel酷睿七代i5处理器看齐。 目前兆芯需要担心的依然是授权的问题，按照此前美国裁定威盛的X86授权早已在2018年4月份过期，之后新的X86指令集无权使用，也就是说以后研发新指令集只能靠兆芯自己了。 海光： 2016年AMD宣布与中国天津海光投资公司达成协议，将X86技术授权给海光公司，自此国内能设计X86处理器的公司又多了一家。但海光处理器是十分受制于AMD的，海光处理器被规定只能在中国销售，不能出口，而且也不知道AMD会不会翻脸，因此海光处理器算不上完全自主可控。 &lt;2&gt; GPU???v.s. NVIDIA &amp; AMD 个人观点，10年以后，见到nVidia的显卡服务器，会发现这是最有趣的事情之一，因为整个机柜的服务器插满GPU，没有一个端口会连接显示器，史上最走狗屎运的公司。：） 相比CPU的国内外差距, GPU领域国内与国际水平差距就太大了. 其中比较有名的行业龙头是景嘉微, 28nm工艺、1.3G主频, 目前已与国产CPU、麒麟系统适配. &lt;3&gt;主存长芯 v.s. Kingston 长江生产的NAND已经开始逐步量产，在成本摊销方面落后于三星。目前主要的问题依然受制于NAND的制造。和SSD一样、我国控制器领域发展繁荣，众多厂商已经开始推出相关产品。 长江存储、合肥长鑫与福建晋华，是中国较为突出的三家存储芯片企业，长江存储主攻 NAND 也就是闪存，长鑫与晋华则是 DRAM（动态随机存取存储器）. 韩国半导体在各种超大规模的投资和收购中逐渐成长，我国的半导体行业也走在这样的路上。目前，全球 DRAM 市场基本上被美韩瓜分，三星、SK 海力士、美光的全球市场份额合计在 95% 左右，而中国庞大的需求，只能依赖进口解决。 专利方面 福建晋华就因为专利问题吃了大亏，不仅被禁售，DRAM 的研发计划也被叫停。而长鑫 2019 年，买下了已经破产的原欧洲存储芯片巨头奇梦达的大量专利。并且在这个基础上进行了创新，专利申请数量达到了 16000 个，还有1000多万份、约 2.8TB 有关 DRAM 的技术文件。 技术方面我国半导体行业依然是处在追赶阶段。目前，长鑫存储把将奇梦达的 46nm 工艺改进到了 10nm 级别，但制程也有高低之分。长鑫的 10nm 存储芯片属于第一代的 1x nm，而美光与 SK 海力士已经开始量产第二代 1y nm制程。而三星电子则是正式宣布已开始量产用于旗舰级手机的 16GB LPDDR5 内存，还计划在今年下半年量产基于 10nm 级（1z）处理技术的16GB LPDDR5内存。 产能方面长鑫第一期投资约为 72 亿美元，预计产能就有 12.5 万片晶圆/月。当然这是理想结果，长鑫预计 2019 年底能达到 4 万片晶圆/月，达到全球产能的 3%。作为对比，三星等巨头单月产量能达到 130 万片，还有较大差距。 未来期待2020年2 月 26 日，长鑫存储正式发布了其 DDR4、LPDDR4X 内存芯片，以及 DDR4 内存条、几款产品均符合国际通行标准规范。对于中国存储来说，长鑫的 DDR4 是一个节点，标志着中国的 DRAM 在应用市场追上了主流水平。不过，技术上的差距仍然肉眼可见。 未来, 服务器端、云存储、汽车等领域，都将逐渐采用 DDR5 规格. 长鑫存储的规划图显示，公司下一代将推出第二代 10nm（17nm）技术，DDR5 也在下一期规划当中。 随着 PC 市场也开始过渡到 DDR5。当这一规格成为主流后，中国厂商们无疑将会面对的更大的挑战。 &lt;4&gt;外存？？？v.s. Seagate &amp; Western Digital &amp; Samsung &amp; Intel HDD的技术我国可以说无可争辩的0作为。最大的市场份额被西部数据和希捷牢牢霸占，东芝紧随其后。 SSD方面，随着长江的颗粒量产，众多控制器厂商耕耘很久，有很好的驱动国内外NAND的经验，和美国这方面差距不大。","link":"/2020/08/30/%E5%88%86%E6%9E%90%E5%9B%BD%E5%86%85%E5%A4%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%AE%E8%B7%9D/"},{"title":"axios &amp; fetch","text":"理解根据需求, 如”一开始就请求信息, 利用信息绘制网页” -&gt; 在页面数据初始化时就发送请求 -&gt; 在componentDidMount中使用axios发送异步ajax请求 假如中途触发请求 -&gt; 在页面数据变化(如搜索关键词)发送请求 -&gt; 在componentWillReceiveProps中使用axios发送异步ajax请求 4.1.1. 前置说明1) React 本身只关注于界面, 并不包含发送 ajax 请求的代码 2) 前端应用需要通过 ajax 请求与后台进行交互(json 数据) 3) react 应用中需要集成第三方 ajax 库(或自己封装) 4.1.2. 常用的 ajax 请求库1) jQuery: 比较重, 如果需要另外引入不建议使用 2) axios: 轻量级, 建议使用 a. 封装 XmlHttpRequest 对象的 ajax b. promise 风格 c. 可以用在浏览器端和 node 服务器端 3) fetch: 原生函数, 但老版本浏览器不支持 a. 不再使用 XmlHttpRequest 对象提交 ajax 请求 b. 为了兼容低版本的浏览器, 可以引入兼容库 fetch.js axios4.2.1. 文档https://github.com/axios/axios 4.2.2. 相关 API1) GET 请求 1234567891011axios.get('/user?ID=12345') .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); });//注意response是一个对象,response.data中包含我们所需数据//确实, 应该先通过输出调试,来观察其结构,然后确定接口axios.get('/user',{ params:{ ID:12345 } }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }); 2) POST 请求 1axios.post('/user',{ firstName:'Fred', lastName:'Flintstone' }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }); 4.3.Fetch4.3.1. 文档1) https://github.github.io/fetch/ 2) https://segmentfault.com/a/1190000003810652 4.3.2. 相关 API1) GET 请求 1234fetch(url).then(function(response){ return response.json() }) //多了一步操作 .then(function(data){ console.log(data) }) .catch(function(e){ console.log(e) }); 2) POST 请求 123fetch(url,{ method:\"POST\", body:JSON.stringify(data), }) .then(function(data){ console.log(data)}) .catch(function(e){ console.log(e) })","link":"/2020/08/30/axios%20&%20fetch/"},{"title":"WebStorm? 爽!","text":"1). 技巧 Live reload 太爽啦!!!! 代码自动补全 webstorm -&gt; settings -&gt; live templates 设置自动代码补全如下: 1234567891011import React, {Component} from 'react'export default class $className$ extends Component { render (){ return ( &lt;div&gt; &lt;/div&gt; ) }} 2). 注意事项 咋导入svg图片不能直接导入啊?!, 得这样 123import logo from '../logo.svg' &lt;img className=\"logo\" src={logo} alt=\"logo\"/&gt; jsx 必须要有标签的结束符 比如 input 标签在html 中可能省略 / 12 &lt;input type=\"text\" class=\"form-control\" placeholder=\"用户名\" /&gt;&lt;img src=\"...\" className=\"card-img-top\" alt=\"...\"/&gt; jsx 中必须使用className, 而不是class! 原因 jsx中不能使用style=’display: none’ 的形式, 必须使用style={(display: ‘none’)} 解释: 其中第一层{}表示是js代码, 第二层{}表示是对象, ‘none’表示是字符串 自定义的MyComponent一定要是组件&amp;标签 首字母大写, 否则不会被渲染!!! 12345import CommentAdd from \"../comment-add/comment-add\";import CommentList from \"../comment-list/comment-list\";&lt;CommentAdd /&gt;&lt;CommentList /&gt; 使用props属性时, 需要导入prop-types库 1234567891011import PropTypes from 'prop-types';TodoAdd.propTypes = { add: PropTypes.func.isRequired, count: PropTypes.number.isRequired }//更优写法, 咋TodoAdd组件对象内添加如下代码static propTypes ={ comments: PropTypes.array.isRequired } 使用ref属性将外部输入导入组件属性时, 注意使用this.input.value ! 123&lt;input type=\"text\" ref={e=&gt; this.user=e} className=\"form-control\" placeholder=\"用户名\" /&gt; this.props.addcomment(this.user.value,this.text.value); 不用每次bind this, 简便写法: 声明组件内自定义函数, 采用箭头函数: 1234userChange = (event) =&gt;{ const author = event.target.value; this.setState({author})} 有点奇怪, 组件内的函数, 咋似乎不用声明, 可以直接写内容??? 似乎在对象中增加属性也是一样的? 此外{author}是新的ES6语法, 等同于{author: author} 对于form标签注意:1. 不要放在p标签下 handle函数中增加 event.preventDefault() // 阻止事件的默认行为: 提交表单会刷新网页","link":"/2020/08/27/WebStrom%E7%9C%9Fnm%E5%A4%AA%E7%88%BD%E4%BA%86!/"},{"title":"JSX知识补充","text":"SX 防止注入攻击你可以安全地在 JSX 当中插入用户输入内容： 123const title = response.potentiallyMaliciousInput;// 直接使用是安全的：const element = &lt;h1&gt;{title}&lt;/h1&gt;; React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。","link":"/2020/08/27/JSX%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"},{"title":"Rebuild Tree with Inorder&amp;Preorder result","text":"输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / 9 20 / 15 7 来源https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/ 解题思路：题目分析：前序遍历特点： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序，以题目示例为例：[ 3 | 9 | 20 15 7 ]中序遍历特点： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序，以题目示例为例：[ 9 | 3 | 15 20 7 ]根据题目描述输入的前序遍历和中序遍历的结果中都不含重复的数字，其表明树中每个节点值都是唯一的。 根据以上特点，可以按顺序完成以下工作： 前序遍历的首个元素即为根节点 root 的值； 在中序遍历中搜索根节点 root 的索引 ，可将中序遍历划分为 [ 左子树 | 根节点 | 右子树 ] 。根据中序遍历中的左（右）子树的节点数量，可将前序遍历划分为 [ 根节点 | 左子树 | 右子树 ] 。 自此可确定 三个节点的关系 ：1.树的根节点、2.左子树根节点、3.右子树根节点（即前序遍历中左（右）子树的首个元素）。 子树特点： 子树的前序和中序遍历仍符合以上特点，以题目示例的右子树为例：前序遍历：[20 | 15 | 7]，中序遍历 [ 15 | 20 | 7 ] 。 根据子树特点，我们可以通过同样的方法对左（右）子树进行划分，每轮可确认三个节点的关系 。此递推性质让我们联想到用 递归方法 处理。 递归解析：递推参数： 前序遍历中根节点的索引pre_root、中序遍历左边界in_left、中序遍历右边界in_right。终止条件： 当 in_left &gt; in_right ，子树中序遍历为空，说明已经越过叶子节点，此时返回 nullnull 。递推工作： 建立根节点root： 值为前序遍历中索引为pre_root的节点值。 搜索根节点root在中序遍历的索引i： 为了提升搜索效率，本题解使用哈希表 dic 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 O(1)O(1)。 构建根节点root的左子树和右子树： 通过调用 recur() 方法开启下一层递归。 左子树： 根节点索引为 pre_root + 1 ，中序遍历的左右边界分别为 in_left 和 i - 1。右子树： 根节点索引为 i - in_left + pre_root + 1（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为 i + 1 和 in_right。返回值： 返回 root，含义是当前递归层级建立的根节点 root 为上一递归层级的根节点的左或右子节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */var buildTree = function(preorder, inorder) { var pre = preorder; var dic = {}; //建立hashmap提高访问速度 for(var i = 0; i &lt; inorder.length; i++){ dic[inorder[i]] = i; } var recurse = function(pre_root,in_left,in_right){ if(in_left&gt;in_right) return null; var root = new TreeNode(pre[pre_root]); var i = dic[root.val]; root.left = recurse(pre_root+1, in_left, i-1); root.right = recurse(pre_root+i-in_left+1, i+1, in_right); return root; } return recurse(0,0,inorder.length-1);}; 时间复杂度 O(N)O(N) ： NN 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N)O(N) ；递归共建立 NN 个节点，每层递归中的节点建立、搜索操作占用 O(1)O(1) ，因此递归占用 O(N)O(N) 。（最差情况为所有子树只有左节点，树退化为链表，此时递归深度 O(N)O(N) ；平均情况下递归深度 O(log_2 N)O(log 2N) ）。 空间复杂度 O(N)O(N) ： HashMap 使用 O(N)O(N) 额外空间；递归操作中系统需使用 O(N)O(N) 额外空间。","link":"/2020/08/25/rebuild%20Tree%20with%20inorder&preorder/"},{"title":"react-脚手架","text":"使用React脚手架创建一个React应用 1). react脚手架1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目 * 包含了所有需要的配置 * 指定好了所有的依赖 * 可以直接安装/编译/运行一个简单效果 2. react提供了一个专门用于创建react项目的脚手架库: create-react-app 3. 项目的整体技术架构为: react + webpack + es6 + babel + eslint2). 创建项目并启动npm install -g create-react-app create-react-app react-app cd react-app npm start3). 使用脚手架开发的项目的特点模块化: js是一个一个模块编写的 组件化: 界面是由多个组件组合编写实现的 工程化: 实现了自动构建/运行/打包的项目4). 组件化编写项目的流程拆分组件 实现静态组件---&gt;静态页面 实现动态组件 动态显示初始化数据 交互","link":"/2020/08/24/react-%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"title":"raft一致性协议基础","text":"以下内容理解基于动画展示, 对于raft一致性能够直观的理解. http://thesecretlivesofdata.com/ 一致性用户对不同服务器的读取, 内容需要一致. 挂掉的服务器在恢复时, 需要恢复到与其他服务器一致 两地集群 之间难通信, 如何保证数据一致 raft 三角色leader, follower, candidate raft 事件 日志复制 user -&gt; leader 我要更新啦!? leader -&gt; follower 准备更新x=5? 将日志传给follower follower -&gt; leader x=5 we are ready! leader 更新 -&gt;follower 我更新啦 follower 好, 我也更新 领导人选举 超时线程: 150ms - 300ms 各自随机 心跳线程: 老大还活着!!! 某follower timesup 成为 candidate, 对自己投票, term更新+1, 问其他follower是否投票 其他follower收到信息, 更新term, 同时vote, 同时更新自己的超时线程. 成为leader之后持续发送心跳(也包含一些数据), follower收到心跳, 则更新自己的超时线程(老大还没死呢? 不要挣当话事人!!!) leader死亡之后, follower超时, 成为candidate, 重复上述历程. 分割投票: 两个节点同时timesup 假如两个节点投票数也一致咋办? 2 个 candidate 处于 term4, 2个follower收到信息之后更新为term4, 然而在term4内没有产生leader, 因此也没有心跳包, 因此follower超时线程没有清零. 其中一个follower超时后进入term5, 重新发起投票, 成为leader. 数据同步 leader通过心跳包传递日志, 网络分区的一致性 A区B区仅内部通讯. 一旦服务器被划区域分布. 没有leader的集群由于没有收到心跳包, 超时线程无人清零, 将选举新的领导人. 尽管存在多个leader, 但是term存在先后记录.对于不同分区的数据库user更新, (每个数据库都知道全局数据库num), 只有占大多数的数据库集群(leader票数)会提交日志更新. 当网络分区恢复, 两方leader都在发送心跳包, 谁的term大听谁的. 少数派的未提交日志被回滚, 同时匹配新的日志 心远的疑问? ​ 网络分区前, 集群term为统一值. 当网络分区时, 无leader的集群会发起新的投票, 之后term+1. 假如该集群不是大多数, 则不会提交日志更新. 最后网络恢复后重新回归一致性? ​ 一致性的设计原则到底是什么呀? 当网络分区时, 到底哪边用户的更新被保存/丢弃呢? ​ 假如我们的原则是: 网络分区时, 每个分区自己可用. 合并时按照大多数原则合并, 则存在矛盾! ​ 最终我确定: 网络分区合并时, 是按照无leader集群日志匹配!!! 然而raft协议仅仅只是这样嘛? 具体实现还有哪些策略呢? 未完待续…","link":"/2020/08/23/raft%E4%B8%80%E8%87%B4%E6%80%A7/"},{"title":"react-生命周期","text":"组件的三个生命周期状态: Mount：插入真实 DOM Update：被重新渲染 Unmount：被移出真实 DOM 生命周期流程: 第一次初始化显示: ReactDOM.render(, containDom) constructor()componentWillMount() : 将要插入, 回调 render() : 用于插入虚拟DOM, 回调 componentDidMount() : 已经插入, 回调 每次更新state: this.setState({}) componentWillReceiveProps(): 接收父组件新的属性 componentWillUpdate() : 将要更新回调 render() : 更新(重新渲染) componentDidUpdate() : 已经更新回调 删除组件: ReactDOM.unmountComponentAtNode(div): 移除组件 componentWillUnmount() : 组件将要被移除回调 常用的方法 render(): 必须重写, 返回一个自定义的虚拟DOMconstructor(): 初始化状态, 绑定this(可以箭头函数代替) componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听 12","link":"/2020/08/22/react%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"react-表单","text":"包含表单的组件分类 a. 受控组件: 表单项输入数据能自动收集成状态 b. 非受控组件: 需要时才手动读取表单输入框中的数据 下述代码中, &lt;input type=&quot;text&quot; value={this.state.username} onChange={this.handleChange} /&gt;采用受控组件, 自动将输入框的内容收集进入状态. &lt;input type=&quot;password&quot; ref={(input) =&gt; this.pwdInput = input} /&gt;采用 非受控组件, 需要时才手动读取表单输入框中的数据. 必须点击submit后才提交 React 的官方文档: 在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。 如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。 使用受控组件更符合react的思想，少使用DOM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*1. 问题: 在react应用中, 如何收集表单输入数据2. 包含表单的组件分类 受控组件 非受控组件*//*需求: 自定义包含表单的组件 1. 界面如下所示 2. 输入用户名密码后, 点击登陆提示输入信息 3. 不提交表单*/class LoginForm extends React.Component { constructor(props) { super(props) this.state = { username: '' } this.handleSubmit = this.handleSubmit.bind(this) this.handleChange = this.handleChange.bind(this) } handleChange(event) { //event表示当前事件, event.target表示触发该事件的元素 this.setState({username: event.target.value}) } handleSubmit(event) { alert(`准备提交的用户名为: ${this.state.username}, 密码:${this.pwdInput.value}`) // 阻止事件的默认行为: 提交表单 event.preventDefault() } render () { return ( //处理submit事件 &lt;form onSubmit={this.handleSubmit} action=&quot;/test&quot;&gt; &lt;label&gt; 用户名: &lt;input type=&quot;text&quot; value={this.state.username} onChange={this.handleChange} /&gt; //value绑定输入框与state中的数据, 只有添加onChange之后才能变化. &lt;/label&gt;&amp;nbsp; &lt;label&gt; 密码: &lt;input type=&quot;password&quot; ref={(input) =&gt; this.pwdInput = input} /&gt; &lt;/label&gt;&amp;nbsp; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; /&gt; &lt;/form&gt; ) }}ReactDOM.render(&lt;LoginForm /&gt;, document.getElementById('example'))","link":"/2020/08/22/react%20%E8%A1%A8%E5%8D%95/"},{"title":"react-组件化开发","text":"组件化开发 1.1. 基本理解和使用1234567891011121314151617181). 自定义的标签: 组件类(函数)/标签2). 创建组件类 //方式1: 无状态函数(简单组件, 推荐使用) function MyComponent1(props) { return &lt;h1&gt;自定义组件标题11111&lt;/h1&gt; } //方式2: ES6类语法(复杂组件, 推荐使用) class MyComponent3 extends React.Component { render () { return &lt;h1&gt;自定义组件标题33333&lt;/h1&gt; } }3). 渲染组件标签 ReactDOM.render(&lt;MyComp /&gt;, cotainerEle)4). ReactDOM.render()渲染组件标签的基本流程 React内部会创建组件实例对象/调用组件函数, 得到虚拟DOM对象 将虚拟DOM并解析为真实DOM 插入到指定的页面元素内部 2.1. 组件的3大属性: state123456789101112131. 组件被称为\"状态机\", 页面的显示是根据组件的state属性的数据来显示2. 初始化指定: constructor() { super() this.state = { stateName1 : stateValue1, stateName2 : stateValue2 } }3. 读取显示: this.state.stateName14. 更新状态--&gt;更新界面 : this.setState({stateName1 : newValue}) 2.2. 组件的3大属性: props1234567891011所有组件标签的属性的集合对象给标签指定属性, 保存外部数据(可能是一个function)在组件内部读取属性: this.props.propertyName作用: 从目标组件外部向组件内部传递数据对props中的属性值进行类型限制和必要性限制 Person.propTypes = { name: React.PropTypes.string.isRequired, age: React.PropTypes.number.isRequired }扩展属性: 将对象的所有属性通过props传递 &lt;Person {...person}/&gt; 2.3. 组件的3大属性: refs组件内包含ref属性的标签元素的集合对象 给操作目标标签指定ref属性, 打一个标识 在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象) 作用: 找到组件内部的真实dom元素对象, 进而操作它面试题问题: 请区别一下组件的 props 和 state 属性? 1) state: 组件自身内部可变化的数据 2) props: 从组件外部向组件内部传递数据, 组件内部只读不修 3.3. 组件的组合设计思路 1) 拆分组件: 拆分界面,抽取组件 2) 实现静态组件: 使用组件实现静态页面效果 3) 实现动态组件 a. 动态显示初始化数据 b. 交互功能(从绑定事件监听开始 思考问题: 数据保存在那个组件中? 两个子组件, 一个读, 一个写. 故放在父组件中. 1234567891011121314//li显示常用技巧: class TodoList extends React.Component { render () { const {todos} = this.props return ( &lt;ul&gt; { //map函数!!! todos.map((todo, index) =&gt; &lt;li key={index}&gt;{todo}&lt;/li&gt;) } &lt;/ul&gt; ) } } 4. 实例实现效果: html 内容: 导入库, 设置容器 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05_components_composing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; //导入所需react库, 与babel库 &lt;script type=\"text/javascript\" src=\"../js/react.development.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/react-dom.development.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/prop-types.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/babel.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/babel\"&gt; ... &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件设计思路:具体实现: 123456789101112131415161718192021222324252627282930313233343536/*1)拆分组件: 拆分界面,抽取组件2)实现静态组件: 使用组件实现静态页面效果3)实现动态组件 ① 动态显示初始化数据 ② 交互功能(从绑定事件监听开始) */// 应用组件[state]class App extends React.Component { constructor (props) { super(props) // 初始化状态 this.state = { todos: ['吃饭', '睡觉', '打豆豆'] } this.add = this.add.bind(this) } add (todo) { const {todos} = this.state todos.unshift(todo) //更新状态 必须使用set State( 修改之后的完整state ) this.setState({todos}) } render () { const {todos} = this.state return ( //只能有一个根标签, 所以用div包括 &lt;div&gt; // 必须制定this.add, 否则只会在render的域搜索 &lt;TodoAdd add={this.add} count={todos.length} /&gt; //此处将APP的state中的todos内容, 传给TodoList的props中的todos属性 &lt;TodoList todos={todos} /&gt; &lt;/div&gt; ) }} 123456789101112131415161718192021222324252627282930313233343536373839 // 添加todo组件 [props,ref] class TodoAdd extends React.Component { //固定套路,记得写上 constructor (props) { super(props) this.addTodo = this.addTodo.bind(this) } // addTodo () { // 读取输入数据 const text = this.sinput.value.trim() // 查检 if(!text) { return } // 保存到todos this.props.add(text) // 清除输入 this.input.value = '' } render () { return ( &lt;div&gt; &lt;h2&gt;Simple TODO List&lt;/h2&gt; //利用ref属性完成外部输入的数据流入到本组件的属性内 //其中ref={input =&gt; this.sinput=input} sinput为定义给TodoAdd组件的属性,可以自己修改. //可以在其他地方通过this.sinput指示该输入框元素,利用this.sinput.value获取填入值 &lt;input type=&quot;text&quot; ref={input =&gt; this.input=input}/&gt;//对应失去焦点的函数为onBlur &lt;button onClick={this.addTodo}&gt;Add #{this.props.count}&lt;/button&gt; &lt;/div&gt; ) } } //由App组件传入的数据, 可以通过this.props.add直接调用 TodoAdd.propTypes = { add: PropTypes.func.isRequired, count: PropTypes.number.isRequired } 12345678910111213141516171819// todo列表组件 [props组件]class TodoList extends React.Component { render () { // 什么意思? props是一个对象,todo就是取出了这个对象的内容,即array const {todos} = this.props return ( &lt;ul&gt; {// 对arry执行map, 其中设置key为index是默认操作 //一行的箭头函数包含了return操作 todos.map((todo, index) =&gt; &lt;li key={index}&gt;{todo}&lt;/li&gt;) } &lt;/ul&gt; ) }}//增加属性, 实际是增加到props下. 相当于增加接受数据的入口.TodoList.propTypes = { todos: PropTypes.array.isRequired} 12// 渲染应用组件标签ReactDOM.render(&lt;App /&gt;, document.getElementById('example'))","link":"/2020/08/21/react%20%E7%BB%84%E4%BB%B6/"},{"title":"面试-css","text":"box模型, link标签和import标签的区别, Flex布局, 浮动清除, css3新特性 box模型标准box模型 IE盒子模型：区别是width 把border也包括了 模型选择: CSS3中引入了box-sizing属性. box-sizing:content-box -&gt; 表示标准的盒子模型 box-sizing:border-box -&gt; IE盒子模型 link标签和import标签的区别 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"\"&gt; link属于html标签，页面被加载时，link会同时被加载. @import是css提供的, @import引用的css会等到页面加载结束后加载。 link是html标签都能用，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的。 Flex布局Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。布局的传统解决方案，基于盒状模型，依赖display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 ? 我一般使用boostrap row col-md-6这样 垂直居中4)利用flex 将父元素设置为display:flex，并且设置align-items:center;justify-content:center; 12345678910111213141516css:.container{ width: 300px; height: 200px; border: 3px solid #546461; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center;}.inner{ border: 3px solid #458761; padding: 20px;} 块级元素和行内元素块级元素 block：p div 独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度 行内元素 inline：span 不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。 转换: a. display:none;不显示该元素，也不会保留该元素原先占有的文档流位置。 b. display:block;转换为块级元素。 c. display:inline;转换为行内元素。 d. display:inline-block;转换为行内块级元素。 visibility=hidden, opacity=0，display:noneopacity=0，该元素隐藏，不会改变页面布局，绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的 visibility=hidden，该元素隐藏起来了，不会改变页面布局，但是不会触发该元素已经绑定的事件 display=none，把元素隐藏起来，改变页面布局，可以理解成在页面中把该元素删除掉一样。 position属性 比较固定定位fixed： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。(如navbar 相对定位relative： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位absolute： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。 粘性定位sticky： 元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。 默认定位Static： 默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。 inherit: 规定应该从父元素继承position 属性的值。 浮动清除? 没听说过. 参考https://www.cnblogs.com/ForEvErNoME/p/3383539.html 方法一：使用带clear属性的空元素 在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;来进行清理。 方法二：使用CSS的overflow属性 给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。 在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 css3新特性 CSS3边框： border-radius边角，box-shadow CSS3背景：background-size： CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片 CSS3文字效果：text-shadow. word-wrap :单词太长的话就可能无法超出某个区域，允许对长单词进行拆分，并换行到下一行：p{word-wrap:break-word;} CSS3 2D转换, 3D转换, 动画","link":"/2020/08/18/%E9%9D%A2%E8%AF%95-CSS/"},{"title":"面试-网络知识","text":"http, http2.0, TCP, UDP, url过程.. http &amp; httpshttp和https的基本概念http: 超文本传输协议 HyperText Transfer Protocol是一个客户端和服务器端请求和应答的标准（TCP）, 用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 明文的. 是无状态的 https: 超文本传输安全协议 HyperText Transfer Protocol Secure是以安全为目标的HTTP通道，即HTTP + SSL https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。 具有安全性的ssl加密传输协议 一般而言，http协议的端口为80，https的端口为443 身份认证 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 https缺点: https握手阶段比较费时，https缓存不如http高效，会增加数据开销。SSL证书也需要钱，功能越强大的证书费用越高。SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。 报文HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文 状态码: 200 OK 客户端请求成功 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。前端提交数据的字段名称和字段类型与后台的实体没有保持一致. json字符串类型 结果给的Obj 304 Not Modified 文件未修改，可以直接使用缓存的文件。如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。 200与304的区别: 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 http版本问题http2.0 : 内容安全，应为http2.0是基于https的 提升访问速度, 允许多路复用(改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。) 首部压缩 二进制格式: http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码(有更多的扩展性) TCP &amp; UDP TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。 TCP提供可靠的服务。无差错，不丢失，不重复，且按序到达. 适合大数据量的交换。 UDP尽最大努力交付，即不保证可靠交付。适合视频? TCP只能是1对1的，UDP支持1对1,1对多。 TCP的首部较大为20字节，而UDP只有8字节。 web sockethttp协议不支持持久性连接。WebSocket是HTML5中的协议，支持持久连续. Http1.0和HTTP1.1都不支持持久性的链接，(HTTP1.1中的keep-alive，将多个http请求合并为1个) HTTP的生命周期通过Request来界定，也就是Request一个Response，那么在Http1.0协议中，这次Http请求就结束了。 在Http1.1中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个Http连接中，可以发送多个Request，接收多个Response。 WebSocket是什么样的协议，具体有什么优点？WebSocket是基于Http协议的, 在握手阶段与Http是相同的。 Cookie、sessionStorage、localStorage的区别共同点：保存在浏览器端，并且是同源的 Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。用来保存用户登录状态(设置过期时间)。跟踪用户行为。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 有效期区别: sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持 localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据 cookie: 只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 作用域区别: sessionStorage：不同的浏览器窗口中不能共享； localStorage：在所有同源窗口都是共享的； cookie：也是在所有同源窗口中共享的 Cookie如何防范XSS攻击XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie： httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。 secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。 自己做的时候就是, sanitize npm库 HTML5新增 更好的实践web语义化，增加了header，footer，nav,aside,section等语义化标签， 在表单方面，为了增强表单，为input增加了color，emial,data ,range等类型 在存储方面，提供了sessionStorage，localStorage,和离线存储 在多媒体方面, 规定了音频和视频元素audio和vedio canvas绘图，支持内联SVG。支持MathML 多线程编程的web worker和websocket协议 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？输入url -&gt; 需要找到这个url域名的服务器ip -&gt; { 查看缓存中是否有记录 -&gt;缓存的查找记录为：`浏览器缓存-&gt;系统缓存-&gt;路由器缓存 缓存中没有 -&gt; hosts文件 还没有 -&gt; 查询DNS服务器 -&gt; 得到服务器的ip地址 } 网络通信阶段: {浏览器根据ip&amp;端口号，构造一个http请求 -&gt; 封装在一个tcp包中 建立TCP链接: tcp包 -&gt; 依次经过传输层，网络层，数据链路层，物理层到达服务器 服务器解析该请求 -&gt; 返回相应的html给浏览器} 构建网页阶段: 浏览器根据这个html来构建DOM树 -&gt; 遇到JS脚本和外部JS连接 -&gt; 停止构建DOM树 -&gt; 执行和下载相应的代码(阻塞) (推荐JS代码应该放在html代码的后面) 构建CSS对象模型树(CSSOM) -&gt;和DOM树合并为渲染树 布局 -&gt; 定各个元素的位置和尺寸 web 性能优化性能测试 chrome f12? 第三方? 降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。 加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。 渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。 react?","link":"/2020/08/18/%E9%9D%A2%E8%AF%95-%E7%BD%91%E7%BB%9C/"},{"title":"This, Call, Aplly, Bind.","text":"在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数中的this指向。 bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 this的理解一个易错点: 123456function a(){ var user = \"xinyuan\"; console.log(this.user); //undefined console.log(this); //Window}a(); 按照我们上面说的this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，等价于window.a(); why?call,apply,bind干什么的？为什么要学这个？ 一般用来指定this的环境，在没有学之前，通常会有这些问题。 123456789var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); }}var b = a.fn; //b获取了a.fn的方法内容,但是this只有被调用的时候才会被确定b(); //undefined 想打印对象a里面的user却打印出来undefined? 其实也就是windows在调用a.fn(); //xinyuan what?1、call() 语法: someObj.call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 将someObj的this指针修改为thisObj对象. 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;b.call(a); call方法除了第一个参数以外还可以添加多个参数，如下： 123456789var a = { user:&quot;xinyuan&quot;, fn:function(e,ee){ console.log(this.user); //xinyuan console.log(e+ee); //3 }}var b = a.fn;b.call(a,1,2); 2、apply() apply方法和call方法有些相似，它也可以改变this的指向 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;b.apply(a); 同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组，如下： 123456789var a = { user:\"xinyuan\", fn:function(e,ee){ console.log(this.user); //xinyuan console.log(e+ee); //11 }}var b = a.fn;b.apply(a,[10,1]); 注意如果call和apply的第一个参数写的是null，那么this指向的是window对象 12345678var a = { user:\"xinyuan\", fn:function(){ console.log(this); //Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…} }}var b = a.fn;b.apply(null); 3、bind() bind方法返回的是一个修改过后的函数。 123456789var a = { user:\"xinyuan\", fn:function(){ console.log(this.user); //xinyuan }}var b = a.fn;var c = b.bind(a);c(); //xinyuan ok，同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。 12345678910var a = { user:\"xinyuan\", fn:function(e,d,f){ console.log(this.user); //xinyuan console.log(e,d,f); //10 1 2 }}var b = a.fn;var c = b.bind(a,10);c(1,2); 总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。 Application（2） 12345678910111213141516function Animal(){ this.name=\"animal\"; this.showName=function(){ console.log(this.name); } } function Dog(){ this.name=\"dog\"; } var animal=new Animal(); var dog=new Dog(); //animal.showName() 对应\"animal\"animal.showName.call(dog);//输出：dog 在上面的代码中，我们可以看到Dog里并没有showName方法，那为什么（this.name）的值是dog呢？ 关键就在于最后一段代码（animal.showName.call(dog)），意思是把animal的方法放到dog上执行，也可以说，把animal 的showName()方法放到 dog上来执行，所以this.name 应该是 dog。 （3）继承 12345678910111213function Animal(name){ this.name=name; this.showName=function(){ console.log(this.name); } } function Dog(name){ Animal.call(this,name); } var dog=new Dog(\"Crazy dog\"); dog.showName();输出：Crazy dog Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么Dog就能直接调用Animal的所有属性和方法。","link":"/2020/08/17/This,%20Call,%20Aplly,%20Bind/"},{"title":"Quick Sort &amp; Merge Sort","text":"快速排序 和 归并排序 都是采用分治法（Divide and Conquer）的非常典型的应用。 Quick Sort vs Merge Sort快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法, 是采用分治法（Divide and Conquer）的一个非常典型的应用。 归并排序的实现由两种方法： 自上而下的递归 recursion（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代 iteration； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 具体实现快排总体逻辑: 12345678910111213function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) { partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); } return arr;} partition实现: 123456789101112function partition(arr, left ,right) { // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) { if (arr[i] &lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index-1;} 归并排序recursion实现: 123456789101112131415161718192021function merge(leftArr, rightArr){ var result = []; while (leftArr.length &gt; 0 &amp;&amp; rightArr.length &gt; 0){ if (leftArr[0] &lt; rightArr[0]) result.push(leftArr.shift()); //把最小的最先取出，放到结果集中 else result.push(rightArr.shift()); } return result.concat(leftArr).concat(rightArr); //剩下的就是合并，这样就排好序了 } function mergeSort(array){ if (array.length == 1) return array; var middle = Math.floor(array.length / 2); //求出中点 var left = array.slice(0, middle); //分割数组 var right = array.slice(middle); return merge(mergeSort(left), mergeSort(right)); //递归合并与排序 } var arr = mergeSort([32,12,56,78,76,45,36]);console.log(arr); // [12, 32, 36, 45, 56, 76, 78] iteration实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function mergeSort(arr){ if(arr.length&lt;2){ return; } //设置子序列的大小 var step=1; var left,right; while(step&lt;arr.length){ left=0; right=step; while(right+step&lt;=arr.length){ mergeArrays(arr,left,left+step,right,right+step); left=right+step; right=left+step; } if(right&lt;arr.length){ mergeArrays(arr,left,left+step,right,arr.length); } step*=2; } return arr;}//对左右序列进行排序function mergeArrays(arr,startLeft,stopLeft,startRight,stopRight){ // 建立一个左、右数组 var rightArr=new Array(stopRight-startRight+1); var leftArr=new Array(stopLeft-startLeft+1); // 给右数组赋值 k=startRight; for(var i=0;i&lt;(rightArr.length-1);++i){ rightArr[i]=arr[k]; ++k; } // 给左数组赋值 k=startLeft; for(var i=0;i&lt;(leftArr.length-1);++i){ leftArr[i]=arr[k]; ++k; } //设置哨兵值，当左子列或右子列读取到最后一位时，即Infinity，可以让另一个剩下的列中的值直接插入到数组中 rightArr[rightArr.length-1]=Infinity; leftArr[leftArr.length-1]=Infinity; var m=0; var n=0; // 比较左子列和右子列第一个值的大小，小的先填入数组，接着再进行比较 for(var k=startLeft;k&lt;stopRight;++k){ if(leftArr[m]&lt;=rightArr[n]){ arr[k]=leftArr[m]; m++; } else{ arr[k]=rightArr[n]; n++; } }}// 测试数据var nums=[6,10,1,9,4,8,2,7,3,5];console.log(mergeSort(nums)); 疑问 空间复杂度如何分析!!!! 与朱博抡交流得知: 对于快排, 尽管每次quicksort都只使用常量, 但一共log(n)轮累积计算, 空间复杂度为O(log n).","link":"/2020/08/16/Quick%20Sort%20&%20Merge%20Sort/"},{"title":"GundamFans V1.4","text":"更新: route refactoring: 将各类别route封装在不同模块中 data association: 增加user, comment 数据关联 准备秋招, 未完待续… route refactoring1234let express = require(\"express\");let router = express.Router(); //使用router替代app//...module.exports = router; 12commentRouter = require(\"./routes/comment\"),app.use(commentRouter); 注意require时的路径问题! 用户权限设计只有登录状态可以进行: 增加评论(自动记录评论用户名) 增加新的机体信息 非登录状态可以进行: 浏览机体信息 设计思路: 对get&amp;post route均进行限制, 仅响应登录状态的request. 增加user 与 comment 的数据关联修改设计comment model 中的author属性: 1234author: { id:{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }, //对应User model的唯一标志_id username: String, //由于经常使用,所以专门提取出来 }, 修改在route中create comment的步骤: 12345let newcomment = { text: req.body.comText, author:{id:req.user._id, username: req.user.username } }comment.create(newcomment,...","link":"/2020/08/14/GundamFansV1.4/"},{"title":"GundamFans V1.3","text":"更新: 增加authentication 依赖库安装123npm i passportnpm i passport-localnpm i passport-local-mongoose UserSchema设计123456789101112let mongoose = require(&quot;mongoose&quot;);let passportLocalMongoose = require(&quot;passport-local-mongoose&quot;);let UserSchema = new mongoose.Schema({ username: String, password: String});//为User植入authentication各种方法UserSchema.plugin(passportLocalMongoose);module.exports = mongoose.model(&quot;User&quot;,UserSchema); 值得注意的是, UserSchema中的属性名称必须为username和password passport config12345678910app.use(require(&quot;express-session&quot;)({ secret: &quot;My favorite gundam is exia!&quot;, resave: false, saveUninitialized: false,}));app.use(passport.initialize());app.use(passport.session());passport.use(new LocalStrategy(User.authenticate()));passport.serializeUser(User.serializeUser());passport.deserializeUser(User.deserializeUser()); Routes设计register设计: 12345678910111213141516171819202122232425//===============//AUTH ROUTES//===============//show register formapp.get(&quot;/register&quot;,function(req,res){ res.render(&quot;register&quot;);})//handle sign up requestapp.post(&quot;/register&quot;,function(req,res){ let newUser = new User({username: req.body.username}); //form与User中必须定义为username User.register(newUser, req.body.password, function(err, user){ if(err){ console.log(err); res.render(&quot;register&quot;); } else { //验证登录 passport.authenticate(&quot;local&quot;, { successRedirect: '/wiki', failureRedirect: '/register', })(req, res, function(){ }) } })}) 在 register form中设计表项name 也必须为”username” “password”对应. login设计: 12345678910111213//show login formapp.get(&quot;/login&quot;,function(req,res){ res.render(&quot;login&quot;);})//handle login request//app.post(&quot;login&quot;, middleware, callback)app.post(&quot;/login&quot;,passport.authenticate(&quot;local&quot;, { successRedirect: '/wiki', failureRedirect: '/login', }), function(req,res){}) 处于middleware的函数会被立即执行. passport.authenticate直接根据login form中的username 和 password 判断能否登录. 加密页面设置设计函数isLoggedIn()如下: 123456function isLoggedIn(req,res,next){ if(req.isAuthenticated()){ return next();//继续执行后续代码(下一个函数) } res.redirect(&quot;/login&quot;);} 将该函数当做middleware function传入需要登录的页面对应的routes, 即可实现进入该页面前验证登录状态功能. 如: 需要用户登录之后才可以使用评论功能: 1app.get(&quot;/wiki/:id/comment/new&quot;,isLoggedIn ,function(req,res){ 页面元素响应用户状态为了实现页面根据用户状态不同而现实不同内容, 则需要将user信息传入对应route, 在express route中天然req.user即是用户信息结构体, 包含username, _id信息. 可以以参数形式传入: 1res.render(&quot;index&quot;,{User: req.user}); 对于实现navbar随着用户状态而选择显示”Login”或”Logout”的功能, 需要在每个页面中都传入req.user数据. 为了简便, 可以使用app.use()功能, 该功能将参数函数当做middleware, 在每个route执行前运行, res.locals.currentUser设置res本地变量供ejs直接使用. 1234app.use(function(req,res,next){ res.locals.currentUser = req.user; next();}); 易错点 定义UserSchema时属性必须为username, password. ejs的form中, 对应input的name也必须为username, password. bootstrap 4 的navbar需要靠右排列时, 使用.ml-auto类. navbar toggle dont work -&gt; include JQuery!!!","link":"/2020/08/13/GundamFansV1.3/"},{"title":"GundamFans V1.2","text":"更新: Comment模块设计: Data Association in Mongoose, 为了安全性使用expressSanitizer Code Refactoring: 划分module, RESTful routing, seedDB()函数生成初试测试数据 RESTful routesRESTful routes 是一种约定俗成的router定义方式, 对应CURD(Create, Update, Read, Delete)的需求, 设计方式如下: HTTP VERB ROUTE Action Used For GET ‘/wiki’ index action index page to display all gundam info GET ‘/wiki/new’ new action displays create gundam info form POST ‘/wiki’ create action creates one gundam GET ‘/wiki/:id’ show action displays one gundambased on ID in the url GET ‘/wiki/:id/edit’ edit action displays edit form based on ID in the url PUT ‘/wiki/:id’ update action replaces an existing article based on ID in the url DELETE ‘/wiki/:id’ delete action deletes one article based on ID in the url PATCH ‘/wiki/:id’ update action modifies an existing article based on ID in the url Comment Module模式设计12345678910let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: {type:String, default:\"Not available\"}, comments: [{ type: mongoose.Schema.Types.ObjectId, ref: 'comment' }] //一个机体可以有多条评价,“`ref`”告知模式分配哪个模型给该字段。});let commentSchema = new mongoose.Schema({ author: String, text: String,}); 读入数据时, 使用populate方法将 id 替换为实际数据: 1234567891011gundamMS.findById(req.params.id) //搜索结果为json的集合 .populate('comments')// 使用作者 id 填充实际作者信息 .exec(function(err,findms){//exec使用回调函数 if(err){ console.log(err); } else { console.log(findms); res.render(\"show\",{ms:findms}); } });//使用时comments对象由id的数组,变为结构体的数组 安全性expressSanitizer为了使评论格式多样, 在show页面的ejs中, 使用&lt;%- %&gt;进行显示输出, 为了避免用户输入&lt;script&gt;&lt;/script&gt;导致执行恶意代码, 使用expressSanitized: 12345678npm i express-sanitizedlet expressSanitized = require(\"express-sanitized\");app.use(bodyparser.urlencoded({extended:true}));app.use(expressSanitized());//bodyparser之后//&lt;script&gt;alert(\"you have been hacked\")&lt;/script&gt;//&lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒消除script部分 data association in mongoose知识补充模式声明时, 属性可以包含其他模式. 1234567891011121314//模式定义const schema = new Schema({ name: String, binary: Buffer, living: Boolean, updated: { type: Date, default: Date.now }, age: { type: Number, min: 18, max: 65, required: true }, mixed: Schema.Types.Mixed, _someId: Schema.Types.ObjectId, //其他模式 array: [], ofString: [String], // 其他类型也可使用数组 nested: { stuff: { type: String, lowercase: true, trim: true } }}) ObjectId：表示数据库中某一模型的特定实例。例如，一本书可能会使用它来表示其作者对象。它实际只包含指定对象的唯一 ID（_id） 。可以使用 populate() 方法在需要时提取相关信息。 Code Refactoring将schema分到单独的文件, 使用module.exports =..来设置出口变量. 同时设计seedDB()函数为数据库增加原始数据. 注意 :为了保证操作的运行次序, 必须把存在先后次序的操作放在call back中. 1234567891011121314151617181920212223242526272829303132function seedDB(){ //remove all gundamMS.remove({},function(err){ if(err){ console.log(err); } else { console.log(\"removed all MS\"); //add MS data.forEach(function(e){ gundamMS.create(e,function(err,newms){ if(err){ console.log(err); } else { console.log(e); comment.create({ author: \"TOM\", text: \"I love this gundam!!!!!\" }, function(err,newcomment){ if(err){ console.log(err); } else{ newms.comments.push(newcomment); newms.save(); } } ) } }) }) } });}","link":"/2020/08/11/GundamFansV1.2/"},{"title":"GundamFans V1.1","text":"GundamFans意在建立一个高达动漫同好分享网站, 分享自己喜爱的高达机体. 后端主体为nodeJS的express框架, 数据库采用mongoDB, 使用mongoose库进行操作. 前端部分使用ejs来编写网页, 使用bootstrap进行装饰, 具有较好的整合性. 主体文件文件树结构: D:.│ index.js│ package-lock.json│ package.json ├───public //需要app.use(express.static(“public”));指示express来serve public目录│ global.css //全局css设置│└───views //express 默认文件夹 │ index.ejs │ landing.ejs │ newms.ejs │ show.ejs │ └───partials //公用代码 header.ejs tail.ejs ├───node_modules(略) 关键点 框架与库的区别 &lt;%- include(“partials/header”) %&gt;实现头尾部ejs代码公用 post指令无法直接解析req.body.param, 需要body-parser库 ejs中&lt;% %&gt;为逻辑代码不显示, &lt;%= %&gt;为显示代码, &lt;%- %&gt;显示且作为html运行? &lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒 代码逻辑首先在本地开启mongoDB, mongod npm库依赖: 123456const { render } = require(\"ejs\");let express = require(\"express\"), app = express(), bodyparser = require(\"body-parser\"); mongoose = require(\"mongoose\"); 相关设置与端口监听: 123456789//指示express来serve public目录app.use(express.static(\"public\"));// 设置使得body自动被parse,可以直接使用req.body.nameapp.use(bodyparser.urlencoded({extended:true}));//默认使用ejs解析views内容app.set(\"view engine\",\"ejs\");app.listen(3000,function(){ console.log(\"gundam runnig\");}) 连接mongoDB, mongoose.connect(&quot;mongodb://localhost:27017/gundam_fans&quot;,{useUnifiedTopology: true,useNewUrlParser: true }); 构建机体视图schema, 构建模型变量. 123456let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: String});let gundamMS = mongoose.model(\"gundamMS\",gundamMSSchema); Router设计: url HTTP verb purpose 对应ejs / get 加载Landing Page landing /wiki get 展示所有机体信息 index /wiki post 根据页面body表单信息创建机体, redirect(“/wiki”) - /wiki/new get 加载机体创建表格, &lt; form action=”/wiki” method=”POST” &gt; newms /wiki/:id get 加载id对应机体详情页 show 具体实现: /wiki get 实现 1234567891011app.get(\"/wiki\",function(req,res){ //获取所有ms信息 //find() gundamMS.find({},function(err,mslist){ if(err){ console.log(err); } else { res.render(\"index\",{mslist: mslist}); } })}) 搜索结果mslist, 传入index页, 取出单个结构即为gundamMSSchema, 多了一个”_id”属性. e.name等属性直接显示, e_id作为参数传入链接MoreInfo. a href=&quot;/wiki/&lt;%= e._id%&gt;&quot; 通过点击MoreInfo, 进入机体详情页: 123456789101112//显示更多机体信息app.get(\"/wiki/:id\",function(req,res){ //index中的btn link包含_id,利用_id去获取description,(req.params.id获取域名中的参数) gundamMS.findById(req.params.id,function(err,findms){ if(err){ console.log(err); } else { res.render(\"show\",{ms:findms}); } }) }) 对于url中带有的参数:id使用 req.params.id进行访问. 新建机体信息的设置: 首先是在wiki/new下rendernewms页面, 在该页面下提供form. 该表格将信息以POST报文的形式传给/wiki页面. 1234567891011121314&lt;form action=\"/wiki\" method=\"POST\" &gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"msname\" placeholder=\"MS name\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"msimg\" placeholder=\"MS picture url\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"description\" placeholder=\"MS description\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;button type=\"submit\" class=\"btn btn-success btn-block\"&gt;GO!&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; /wiki对POST报文进行响应: 12345678910111213141516app.post(\"/wiki\",function(req,res){ let newms = { name:req.body.msname, img:req.body.msimg, description:req.body.description, } gundamMS.create(newms,function(err,newlycreated){ if(err){ console.log(err); } else { res.redirect(\"/wiki\"); } }) }) 其中注意页面信息由req.body.msname获取, 注意此处需要提前引入bodyparser依赖: 123bodyparser = require(\"body-parser\");// 设置使得body自动被parse,可以直接使用req.body.nameapp.use(bodyparser.urlencoded({extended:true})); MongoDB使用整理:首先在本地开启mongoDB, mongod 连接mongoDB, mongoose.connect(&quot;mongodb://localhost:27017/gundam_fans&quot;,{useUnifiedTopology: true,useNewUrlParser: true }); 构建机体视图schema, 构建模型变量. 1234567let gundamMSSchema = new mongoose.Schema({ name: String, img: String, description: String});// 使用模式“编译”模型let gundamMS = mongoose.model(\"gundamMS\",gundamMSSchema); 第一个参数是为模型所创建集合的别名（Mongoose 将为 SomeModel 模型创建数据库集合），第二个参数是创建模型时使用的模式。 创建和修改文档插入新数据操作: 123456789101112gundamMS.create( {name:\"ASW-G-08 Gundam Barbatos\", img:\"...\", description:\"...\" },function(err,ms){ if(err){ console.log(err); } else{ console.log(ms); }}); 或使用save(): 123456789// 创建一个 SomeModel 模型的实例const awesome_instance = new SomeModel({ name: '牛人' });// 传递回调以保存这个新建的模型实例awesome_instance.save( function (err) { if (err) { return handleError(err); } // 已保存}); 可以使用“圆点”加字段名来访问、修改新记录中的字段。修改后必须调用 save() 或 update() 以将改动保存回数据库。 12345678910// 使用圆点来访问模型的字段值console.log(awesome_instance.name); // 控制台将显示 '也是牛人'// 修改字段内容并调用 save() 以修改记录awesome_instance.name = \"酷毙了的牛人\";awesome_instance.save( function(err) { if (err) { return handleError(err); } // 已保存}); 搜索纪录 findById()：用指定 id 查找文档（每个文档都有一个唯一 id）。 findOne()：查找与指定条件匹配的第一个文档。 findByIdAndRemove()、findByIdAndUpdate()、findOneAndRemove()、 findOneAndUpdate()：通过 id 或条件查找单个文档，并进行更新或删除。以上是更新和删除记录的便利函数。 查找获取list of elements: 1234567gundamMS.find({},function(err,mslist){ if(err){ console.log(err); } else { console.log(mslist); } }) 查找获取单个element: 1234567gundamMS.findById(req.params.id,function(err,findms){ if(err){ console.log(err); } else { res.render(\"show\",{ms:findms}); }}) 进阶: 以下代码展示了如何在数据库中找到所有网球运动员，并返回运动员姓名和年龄字段。 123456789101112const Athlete = mongoose.model('Athlete', yourSchema);// SELECT name, age FROM Athlete WHERE sport='Tennis'Athlete.find( { 'sport': 'Tennis' }, 'name age', function (err, athletes) { if (err) { return handleError(err); } // 'athletes' 中保存一个符合条件的运动员的列表 }); 若像上述代码那样指定回调，则查询将立即执行。搜索完成后将调用回调。 若未指定回调，则 API 将返回 Query 类型的变量。可以使用该查询对象来构建查询，随后使用 exec() 方法执行（使用回调）。 12345678910111213141516171819202122232425262728// 寻找所有网球运动员const query = Athlete.find({ 'sport': 'Tennis' });// 查找 name, age 两个字段query.select('name age');// 只查找前 5 条记录query.limit(5);// 按年龄排序query.sort({ age: -1 });// 以后某个时间运行该查询query.exec(function (err, athletes) { if (err) { return handleError(err); } // athletes 中保存网球运动员列表，按年龄排序，共 5 条记录})//等价于Athlete. find(). where('sport').equals('Tennis'). where('age').gt(17).lt(50). // 附加 WHERE 查询 limit(5). sort({ age: -1 }). select('name age'). exec(callback); // 回调函数的名字是 callback 查询还能做更多。请参阅 查询（Mongoose 英文文档） 公用html代码header部分 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;I'm Gundam!!!&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"/global.css\"&gt; &lt;/head&gt; &lt;!-- 设计navbar --&gt; &lt;body&gt; tail部分 123&lt;p class=\"text-center\"&gt;Copyright: XinyuanCai.07/2020&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 升级req.body.blog blog[name] blog[img] npm i express-sanitizer 1234567891011form action: /xx/_id?method=PUT method=\"POST\"let expressSanitizer = require(\"express-sanitizer\");let methodOverride = require(\"method-override\");//after bodyparserapp.use(expressSanitizer())app.use(methodOverride(\"_method\"))// 博客的content 我们支持html格式,则...//&lt;%- %&gt;读取输入时, 对方可以输入&lt;script 代码进行攻击. sanitize消毒消除script部分","link":"/2020/08/07/GundamFansV1.1/"},{"title":"Tree BFS DFS","text":"使用callback以及call技术, 写出标准化的BFS,DFS. 以及扩展性极强的contain. Tree基本数据结构: 12345678910//JS treefunction Node(data){ this.data = data; this. parent = null; this.children = [];}function Tree(data){ this.root = new Node(data);} recurse DFS: 1234567891011Tree.prototype.traverseDF = function(callback){ ( function recurse(currNode){ let length = currNode.children.length; callback(currNode);//先序遍历 for(let i = 0; i&lt;length; i++){ recurse(currNode.children[i]); //当只有两个children时,插在中间则为中序遍历 } //callback(currNode);//后序遍历 } )(this._root);}; 立即使用树的根节点作为其参数调用recurse。 此时，currentNode指向当前节点。 进入for循环并且从第一个子节点开始，每一个子节点都迭代一次currentNode函数。 在for循环体内，使用currentNode的子元素调用递归。 确切的子节点取决于当前for循环的当前迭代。 当currentNode不存在子节点时，我们退出for循环并callback我们在调用traverseDF（callback）期间传递的回调。 queue BFS: 1234567891011121314//queue BFSTree.prototype.traverseBF = function(callback){ let queue = []; queue.push(this._root); let currNode = queue.shift(); while(currNode){ let length = currNode.children.length; for(let i = 0; i&lt;length; i++){ queue.push(currNode.children[i]); } callback(currNode); currNode = queue.shift(); }} 创建 Queue的实例。 将调用traverseBF(callback)的节点添加到Queue的实例。 定义一个变量currentNode并且将他的值初始化为刚才添加到队列里的node 当currentNode指向一个节点时，执行wille循环里面的代码。 用for循环去迭代currentNode的子节点。 在for循环体内，将每个子元素加入队列。 获取currentNode并将其作为callback的参数传递。 将currentNode重新分配给正从队列中删除的节点。 直到currentNode不在指向任何节点-也就是说树中的每个节点都访问过了-重复4-8步。 自定义的contain contains(callback, traversal)接收两个参数：搜索的数据和遍历的类型。 123Tree.prototype.contains = function(callback, traversal) { traversal.call(this, callback);}; 使用示例： 123456// tree is an example of a root nodetree.contains(function(node){ if (node.data === 'two') { console.log(node); }}, tree.traverseBF); 深度优先遍历问题二叉树的所有路径-257 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 123456789101112输入: 1 / \\2 3 \\ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3复制代码 来源：力扣（LeetCode） 链接：leetcode-cn.com/problems/bi… 路径(n)为当前node, 与路径(n.left)和路径(n.right)的拼接. 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {string[]} */var binaryTreePaths = function(root) { let res = []; if(!root){return res}; if((!root.left)&amp;&amp;(!root.right)){return [root.val]}; let left_result = binaryTreePaths(root.left); let right_result = binaryTreePaths(root.right); left_result.forEach(e =&gt;{ res.push(root.val+&quot;-&gt;&quot;+e); }); right_result.forEach(e =&gt;{ res.push(root.val+&quot;-&gt;&quot;+e); }); return res;}; 广度优先遍历（BFS）问题在每个树行中找最大值-515 leetcode-cn.com/problems/fi… 您需要在二叉树的每一行中找到最大的值。 1234567891011输入: 1 / \\ 3 2 / \\ \\ 5 3 9输出: [1, 3, 9]复制代码","link":"/2020/08/04/Tree%20BFS%20DFS/"},{"title":"LC_training(2)","text":"易错点 forEach()函数体中,无法使用return终止运行,也不能使用break,continue. 应该使用其他语法. 123456MyHashSet.prototype.contains = function(key) { this.set.forEach(function(e){ if(e == key) return true; }); return false;}; 今天遇到一个还挺厉害的简单题解法: 有效的括号-20 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。其实就是栈问题.leetcode-cn.com/problems/va… 常规写法: 略 进阶写法: 12345678910111213141516171819202122232425var isValid = function(s) { let map = { \"{\":\"}\", \"(\":\")\", \"[\":\"]\" }; var stack = []; let len = s.length; let top = \"\"; for (let char of s){ //char of s将s当做一个数组??如何办到的 if (map[char]) { //利用map取代一个个判断条件 stack.push(char); top = char; } else { if(char == map[top]){ //利用map构建对应关系 stack.pop(); top = stack[stack.length-1]; } else return false; } } return !stack.length; //return的条件简化};","link":"/2020/08/02/LeetCode%E5%BF%83%E5%BE%97(2)/"},{"title":"LinkedList basis","text":"简单的链表训练 链表基本实现:12345678910111213141516171819202122232425262728293031323334353637//结点的构造函数function Node(e){ this.e = e; this.next = null;}//搜索item元素所在nodefunction find (item){ let currNode = this.head; while(currNode.e!=item){ currNode = currNode.next; } return currNode;}//在item元素之前插入newelementfunction insert (newElement,item){ let newNode = new Node(newElement); let target = this.find(item); newNode.next= target.next; target.next = newNode;}function display(){ let currNode = this.head; while(currNode){ console.log(currNode.e); currNode = currNode.next; }}//链表的构造函数function LList() { this.head = new Node('head');//头结点 this.find = find; //定义函数? this.insert = insert; this.display = display;} 典型例题:两两交换链表中的节点-24 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例: 12给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.复制代码 来源：力扣（LeetCode） 链接：leetcode-cn.com/problems/sw… 1234567891011121314//实现对链表两个节点的交换function switchwithnext(node){ if(!node) return null; let nextnode = node.next; if(!nextnode) return node; node.next = switchwithnext(nextnode.next); nextnode.next = node; return nextnode;}function solution(head){ let res = switchwithnext(head); return res;} 难吗?还行,重点是next的理解,要画图.","link":"/2020/07/31/LinkedList/"},{"title":"LC_training(1)","text":"犯过的那些错误 一个专属JS的不起眼的坑!!! 1234for(var i in nums){ if(nums[i]==nums[i+1]){ ... } 上述代码中nums[i+1]结果undifined, 因为for in遍历的原理是什么呢? 其实是把nums数组当做Obejct(一个键值对结构), 其中i 是对于其key的遍历, 因此i 其实是字符串”0”, 而i+1则表示”01”, 自然是找不到结果. 对此问题我们深入研究, 123456 const arr = [ “ a”，“ b”，“ c” ]; arr.test = “坏”；//既然数组是object,就可以添加非数字属性 for (let i in arr) { console.log(i+\":\"+ arr[i]); // 打印\"0:a, 1:b, 2:c, test:bad\"} 因此在 Js的数组遍历中,我们应该避免使用for/in, 而可以选择for/of替代. 123456 for (const element of arr) { console.log(element); } for (let i = 0; i &lt; arr.length; ++i) { console.log(arr[i]);} 此外, for，for/in与for/of会保留外部作用域的this。 对于forEach， 除非使用箭头函数，它的回调函数的 this 将会变化。 1234567891011 \"use strict\"; const arr = [\"a\"]; arr.forEach(function() { console.log(this); // 打印undefined }); arr.forEach(() =&gt; { console.log(this); // 打印{}}); JS对象 与 哈希表: js中的对象是基于哈希表结构的,而哈希表的查找时间复杂度为O(1),所以很多人喜欢用对象来做映射,减少遍历循环. 对于找数组重复元素, 我们的核心是利用key存储数据, 利用value来记录该元素是否存在(bool), 但是需要注意的是key值会被转化为字符串, 因此数组中元素类型应该保持一致. 核心: object, 是属性名-属性值的键值对, 对于属性名(字符串)的ASII码进行哈希算法的应用, 这样就构建了高效(O(1)时间存取)的HashMap结构了. 一个很蠢的问题: 123let tmp = nums[i];nums[i] = nums[nums[i]];nums[nums[i]] = tmp; 经常在自身哈希的题目中犯错, nums[i]的值被改变了呀! 应该提前将nums[i]的值保存下来: 12let numi = nums[i];[nums[i],nums[numi]] = [nums[numi],nums[i]]//解构赋值语法ES6 拼写：querySelector,querySelectorAll,addEventListener, querySelectorAll的函数返回为 Nodelist, 千万不要直接使用！！！ 题解 找出数组中重复的数字。长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 排序之后遍历判断相邻元素: nlogn, n var findRepeatNumber = function(nums) { nums.sort(); for(let i=0; i&lt;nums.length;i++){ if(nums[i]==nums[i+1]){ return 9; } } return 0; }; &lt;!--￼6--&gt; 采用基于对象的hash映射, n, n (基于假设set存取均为O(1)): var findRepeatNumber = function(nums) { let obj = {}; for(num of nums){ if(!obj[num]){ obj[num]=true; } else{ return num; } } }; 所有数字都在 0 ～ n-1 的范围内。因此不需要额外开辟空间，每次遍历时，检查当前元素是否放在了正确位置上（例如元素 i 应该放在下标为 i 的位置上）。如果放在了正确位置上，那么继续循环。否则： 下标为 num 的元素 == num，说明当前元素 num 是重复的，直接返回下标为 num 的元素 != num，交换当前元素和下标为 num 的元素，将当前元素放入到正确位置上 n, 1 (基于假设set存取均为O(1)) 二维数组中的查找观察大小规则, 利用单调性查找元素!","link":"/2020/07/30/LeetCode%E5%BF%83%E5%BE%97(1)/"},{"title":"Arrow Func &amp; set map","text":"箭头函数箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 应用场合:普通函数会重新绑定this, 箭头函数不会重新绑定this. 根据需求选择…… 面试经典: 当前this是什么? 举例子: 12345678910111213document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听})-----------------------------------------------------------console.log(this) //输出windowdocument.getElementById(\"the-button\").addEventListener(\"click\",()=&gt;{ console.log(this);//输出的是window this.classList.add(\"bigger\");//添加监听失败}) 原因是箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 这里该函数作为addEventListener的参数, 其实是被button 调用 更进一步的例子: 12345678910111213141516171819202122232425262728293031323334document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听 //希望等待一秒后变化 setTimeout(function(){ console.log(this); //why! 指向window???? 因为这里发生函数调用,则重新绑定,而setTimeout不是被别人调用的,所以是window this.innerHTML = \"clicked\"; })})--------解决方法 一:保存临时this (很乱)-------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); var tmpthis = this; setTimeout(function(){ console.log(tmpthis); tmpthis.innerHTML = \"clicked\"; })}) --------最好的方法: 箭头函数替代--------------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); setTimeout(()=&gt;{ console.log(this); this.innerHTML = \"clicked\"; })}) ==待突破的难点:== ==this 的值是什么?== 12345const ages =[14,19,21];ages.map(age=&gt; \"his age is \"+age );ages.filter(age=&gt; age&gt;18); set123456789101112const numSet = new Set();numSet.add(e) //返回setnumSet.delete(e) //返回boolnumSet.has(e) //返回boolnumSet.size //数组才是length//遍历 或者for of (原本的for in)numSet.forEach(number=&gt; console.log(number)) map123456789101112131415161718const person = new Map();person.set(\"name\",\"laobi\")person.set(\"age\",18) //value可以是不同类型的person.get(\"name\") //返回valueperson.size //数组才是length person.has(\"name\") //返回bool//添加重复的key呢?person.set(\"name\",\"xiaocai\") //将会替换原本的valueperson.delete(\"age\") //返回bool//遍历 或者for of (原本的for in)person.forEach(箭头函数)","link":"/2020/07/30/Arrow%20Func%20&%20set%20map/"},{"title":"Todo-List","text":"一个简单的利用JQuery实现+CSS修饰的静态网页备忘录. 成品 技术重点 JQuery对click, keypress事件的监听 复习bootstrap与css 技术难点 onclick只能对已经存在的元素监听 解决方案: 1234//$(\"li\").on(\"click\",function(){ //尽管使用on,但是还是没法应用到新的li中,因为$(li)绑定行为一开始就执行了,此时只有三个li.$(\"ul\").on(\"click\",\"li\",function(){ //而绑定ul之后, 在click时,再去确认click是其中的哪个li,则可以解决该问题.即$()中的元素一定一开始就要存在,因此此类问题绑定其父节点即可 $(this).toggleClass(\"finished\");}) span元素存在于ul元素中, 点击span会触发ul的监听执行函数 解决方案: e.stopPropagation(); 中断回调传递 1234567//remove evert when click X before it$(\"ul\").on(\"click\",\"span\",function(e){ $(this).parent().fadeOut(function(){ $(this).remove(); //此处使用this,而不是parent,因为已经在fadeOut中,此时this已经指向parent }); //parent()方法返回父元素 e.stopPropagation(); //span处于li,ul,body中,则事件e可能导致其他回调函数,终止传播函数stopPropagation由jQuery提供}) JS代码对html内容的影响 解决方案:$(“ul”).append()函数, 为ul增加item 12345678$(\"input\").on(\"keypress\",function(e){ if(e.which == 13){ let newevent = $(this).val(); $(this).val(\"\"); //清空输入栏 $(\"ul\").append(\"&lt;li&gt;&lt;span&gt;&lt;i class=\\\"fa fa-trash\\\" aria-hidden=\\\"true\\\"&gt;&lt;/i&gt; &lt;/span&gt;\"+newevent+\"&lt;/li&gt;\"); }}) 如何设计hover滑动淡出淡入特效, 需要结合css和JQuery 12345678910111213span{ transition: 0.3s linear; height: 35px; width: 0; opacity: 0; /*设置能见度,优化显示*/}/*有意思的写法 表示hover的li里面的span*/li:hover span{ width: 35px; opacity: 1.0;} 关于fadeout之后remove的研究 123456789//effect 部分$(\"button\").on(\"click\",function(){ $(\"div\").fadeOut(1000,function(){//fade的同时执行函数 //fade只是隐藏显示,在html中仍然存在 //$(this).remove 从html中删除 }); $(\"div\").remove();//不妥,参考setInterval事件队列,fade未执行完成就删除了 })","link":"/2020/07/28/todolist/"}],"tags":[{"name":"ES6特性","slug":"ES6特性","link":"/tags/ES6%E7%89%B9%E6%80%A7/"},{"name":"LC","slug":"LC","link":"/tags/LC/"},{"name":"易错","slug":"易错","link":"/tags/%E6%98%93%E9%94%99/"},{"name":"Full Stack","slug":"Full-Stack","link":"/tags/Full-Stack/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"ejs","slug":"ejs","link":"/tags/ejs/"},{"name":"mongoDB","slug":"mongoDB","link":"/tags/mongoDB/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"Front-End","slug":"Front-End","link":"/tags/Front-End/"},{"name":"JQuery","slug":"JQuery","link":"/tags/JQuery/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"url过程","slug":"url过程","link":"/tags/url%E8%BF%87%E7%A8%8B/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"分布式数据库","slug":"分布式数据库","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"categories":[{"name":"闲谈","slug":"闲谈","link":"/categories/%E9%97%B2%E8%B0%88/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"Application","slug":"Application","link":"/categories/Application/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"}]}