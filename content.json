{"pages":[],"posts":[{"title":"Beginning of Everything 起点","text":"“hust&gt; rm -rf”, 了结过往, 面向未来, 是我为HUST计算机学院设计的毕业衫图案 2020年, 没有想象中美好的毕业仪式, 大学四年生活匆匆收场. 本以为最最美好的”大学四年级”结果却是如此孤独寂寥, 假如不是这场疫情所致, 也许现在我已经做好了去美国留学的打算. 在家颓靡的这几个月, 美其名曰”韬光养晦”, 其实也只是浑浑噩噩. 现已是7月底, 大家纷纷找了实习, 而我却迟迟没有迈出这一步. 既然人生这么多遗憾, 为什么不记录下那些美好的时刻呢? 于是乎, 我建立起这个博客, 意在记录那些学习技术过程中的快乐时光. 正如我博客的slogan所言 “have fun with tech“ , 学习技术的过程本身就是一种快乐, 正如男孩学会了积木的拼接, 进而用乐高创造出属于自己的快乐世界. 我也希望在学习的过程中, 记录这些创造性的快乐时刻, 与你们分享技术的乐趣. Go! Go! Xinyuan, explore the Tech &amp; have Fun !","link":"/2020/07/28/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"},{"title":"LC心得(1)","text":"犯过的那些错误 一个难题 1234for(var i in nums){ if(nums[i]==nums[i+1]){ ... } 上述代码中nums[i+1]结果undifined, 因为for in遍历的原理是什么呢? 其实是把nums数组当做Obejct(一个键值对结构), 其中i 是对于其key的遍历, 因此i 其实是字符串”0”, 而i+1则表示”01”, 自然是找不到结果. 对此问题我们深入研究, 123456 const arr = [ “ a”，“ b”，“ c” ]; arr.test = “坏”；//既然数组是object,就可以添加非数字属性 for (let i in arr) { console.log(i+\":\"+ arr[i]); // 打印\"0:a, 1:b, 2:c, test:bad\"} 因此在 Js的数组遍历中,我们应该避免使用for/in, 而可以选择for/of替代. 123456 for (const element of arr) { console.log(element); } for (let i = 0; i &lt; arr.length; ++i) { console.log(arr[i]);} 此外, for，for/in与for/of会保留外部作用域的this。 对于forEach， 除非使用箭头函数，它的回调函数的 this 将会变化。 1234567891011 \"use strict\"; const arr = [\"a\"]; arr.forEach(function() { console.log(this); // 打印undefined }); arr.forEach(() =&gt; { console.log(this); // 打印{}}); JS对象 与 哈希表: js中的对象是基于哈希表结构的,而哈希表的查找时间复杂度为O(1),所以很多人喜欢用对象来做映射,减少遍历循环. 对于找数组重复元素, 我们的核心是利用key存储数据, 利用value来记录该元素是否存在(bool), 但是需要注意的是key值会被转化为字符串, 因此数组中元素类型应该保持一致. 核心: object, 是属性名-属性值的键值对, 对于属性名(字符串)的ASII码进行哈希算法的应用, 这样就构建了高效(O(1)时间存取)的HashMap结构了. 一个很蠢的问题: 123let tmp = nums[i];nums[i] = nums[nums[i]];nums[nums[i]] = tmp; 经常在自身哈希的题目中犯错, nums[i]的值被改变了呀! 应该提前将nums[i]的值保存下来: 12let numi = nums[i];[nums[i],nums[numi]] = [nums[numi],nums[i]]//解构赋值语法ES6 拼写：querySelector,querySelectorAll,addEventListener, querySelectorAll的函数返回为 Nodelist, 千万不要直接使用！！！ 题解 找出数组中重复的数字。长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内 排序之后遍历判断相邻元素: nlogn, n var findRepeatNumber = function(nums) { nums.sort(); for(let i=0; i&lt;nums.length;i++){ if(nums[i]==nums[i+1]){ return 9; } } return 0; }; &lt;!--￼6--&gt; 采用基于对象的hash映射, n, n (基于假设set存取均为O(1)): var findRepeatNumber = function(nums) { let obj = {}; for(num of nums){ if(!obj[num]){ obj[num]=true; } else{ return num; } } }; 所有数字都在 0 ～ n-1 的范围内。因此不需要额外开辟空间，每次遍历时，检查当前元素是否放在了正确位置上（例如元素 i 应该放在下标为 i 的位置上）。如果放在了正确位置上，那么继续循环。否则： 下标为 num 的元素 == num，说明当前元素 num 是重复的，直接返回下标为 num 的元素 != num，交换当前元素和下标为 num 的元素，将当前元素放入到正确位置上 n, 1 (基于假设set存取均为O(1)) 二维数组中的查找观察大小规则, 利用单调性查找元素!","link":"/2020/07/30/LeetCode%E4%BB%A3%E7%A0%81%E5%BF%83%E5%BE%97/"},{"title":"字符串的replace() &amp; RegExp","text":"字符串的replace方法JavaScript字符串提供了一个replace方法。replace方法可以接受两个参数：第一个参数可以使RegExp对象或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串。如果想替换所有的字符串，则必须使用正则表达式。 123456789101112131415161718192021222324252627var str=\"hello world\";//第一个参数为字符串则只替换第一个匹配的,生成新的字符串,不会替代原有字符串var str1=str.replace(\"o\",\"h\");console.log(str1);//hellh worldvar str1=str.replace(/o/g,\"h\");console.log(str1);//hellh whrld//传参func,可以对(匹配到的字符串,匹配的位置,原始字符串)根据需要变换, 执行逻辑是遍历,每匹配一次则调用该函数,return则表示替换的字符串.var str1=str.replace(/o/g,function(match,pos,orginText){ console.log(pos); return \"a\"; });console.log(str1);//hella warld//也可写作function($0)替代match,假如没有子表达式. 若存在子表达式,则arg1表示整体匹配,arg2...表示子表达式匹配,直到结束var str1=str.replace(/[ol]/g,function(match,pos,orginText){console.log(pos);if(match==\"o\"){ return \"a\"; }else { return \"b\"; } });console.log(str1);//hebba warbd 对于正则表达式的理解 字符类 [abx] 表示匹配a或b或x任意一个 字符类取反 [ ^abx] 表示匹配任意一个不是a或b或x 范围类 [a-z] a到z(闭区间) 预定义类 . 除了回车和换行,\\d数字,\\D非数字,\\w字母数字下划线,\\W非以上 边界 ^abc 不在[]内 以abc作为开始 $abc 以abc作为结束 ? + * {n,m} 0或1次出现, 1或多次, 0或多次,n到m次 () 用于分组 | 表示或者 123456789101112// 匹配字符串 'Byron' 连续出现3次的场景。 Byron{3} // 匹配'n'连续出现了3次的场景(Byron){3} // 匹配'Byron'连续出现了3次的场景// 匹配字母+数字连续出现3次的场景'a1b2c3d4'.replace(/[a-z]\\d{3}/g, 'X'); // a1b2c3d4'a1b2c3d4'.replace(/([a-z]\\d){3}/g, 'X'); // Xd4'ByronsperByrCasper'.replace(/Byr(on|Ca)sper/g, 'X'); // XX// 实现：2017-05-01 =&gt; 05/01/2017'2017-05-01'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g, '$2/$3/$1'); // 05/01/2017 g global 全文搜索，不添加则搜索到第一个匹配停止 i ignore case 忽略大小写，默认大小写敏感 m multiple lines 多行搜索 123456789101112131415var mulStr = ' @123 @456 @789';mulStr.replace(/^@\\d/g, 'X');// 'X23// @456// @789'mulStr.replace(/^@\\d/gm, 'X');// 'X23// X56// X89' 支持正则表达式的方法 方法 描述 search 检索与正则表达式相匹配的值。 match 找到一个或多个正则表达式的匹配。 replace 替换与正则表达式匹配的子串。 split 把字符串分割为字符串数组","link":"/2020/07/30/%E5%88%B7%E9%A2%98%E8%BF%87%E7%A8%8B%E5%AD%A6%E7%9A%84%E6%96%B0%E4%B8%9C%E8%A5%BF/"},{"title":"arrow func 与 set map","text":"箭头函数箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 应用场合:普通函数会重新绑定this, 箭头函数不会重新绑定this. 根据需求选择…… 面试经典: 当前this是什么? 举例子: 12345678910111213document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听})-----------------------------------------------------------console.log(this) //输出windowdocument.getElementById(\"the-button\").addEventListener(\"click\",()=&gt;{ console.log(this);//输出的是window this.classList.add(\"bigger\");//添加监听失败}) 原因是箭头函数不会重新绑定this, this指向最外层; 而普通函数会重新绑定this到 是谁调用了该函数, 这里该函数作为addEventListener的参数, 其实是被button 调用 更进一步的例子: 12345678910111213141516171819202122232425262728293031323334document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\");//成功添加监听 //希望等待一秒后变化 setTimeout(function(){ console.log(this); //why! 指向window???? 因为这里发生函数调用,则重新绑定,而setTimeout不是被别人调用的,所以是window this.innerHTML = \"clicked\"; })})--------解决方法 一:保存临时this (很乱)-------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); var tmpthis = this; setTimeout(function(){ console.log(tmpthis); tmpthis.innerHTML = \"clicked\"; })}) --------最好的方法: 箭头函数替代--------------------------document.getElementById(\"the-button\").addEventListener(\"click\",function(){ console.log(this);//输出的是button this.classList.add(\"bigger\"); setTimeout(()=&gt;{ console.log(this); this.innerHTML = \"clicked\"; })}) ==待突破的难点:== ==this 的值是什么?== 12345const ages =[14,19,21];ages.map(age=&gt; \"his age is \"+age );ages.filter(age=&gt; age&gt;18); set123456789101112const numSet = new Set();numSet.add(e) //返回setnumSet.delete(e) //返回boolnumSet.has(e) //返回boolnumSet.size //数组才是length//遍历 或者for of (原本的for in)numSet.forEach(number=&gt; console.log(number)) map123456789101112131415161718const person = new Map();person.set(\"name\",\"laobi\")person.set(\"age\",18) //value可以是不同类型的person.get(\"name\") //返回valueperson.size //数组才是length person.has(\"name\") //返回bool//添加重复的key呢?person.set(\"name\",\"xiaocai\") //将会替换原本的valueperson.delete(\"age\") //返回bool//遍历 或者for of (原本的for in)person.forEach(箭头函数)","link":"/2020/07/30/set&map/"},{"title":"Todo-List","text":"一个简单的利用JQuery实现+CSS修饰的静态网页备忘录. 成品 技术重点 JQuery对click, keypress事件的监听 复习bootstrap与css 技术难点 onclick只能对已经存在的元素监听 解决方案: 1234//$(\"li\").on(\"click\",function(){ //尽管使用on,但是还是没法应用到新的li中,因为$(li)绑定行为一开始就执行了,此时只有三个li.$(\"ul\").on(\"click\",\"li\",function(){ //而绑定ul之后, 在click时,再去确认click是其中的哪个li,则可以解决该问题.即$()中的元素一定一开始就要存在,因此此类问题绑定其父节点即可 $(this).toggleClass(\"finished\");}) span元素存在于ul元素中, 点击span会触发ul的监听执行函数 解决方案: e.stopPropagation(); 中断回调传递 1234567//remove evert when click X before it$(\"ul\").on(\"click\",\"span\",function(e){ $(this).parent().fadeOut(function(){ $(this).remove(); //此处使用this,而不是parent,因为已经在fadeOut中,此时this已经指向parent }); //parent()方法返回父元素 e.stopPropagation(); //span处于li,ul,body中,则事件e可能导致其他回调函数,终止传播函数stopPropagation由jQuery提供}) JS代码对html内容的影响 解决方案:$(“ul”).append()函数, 为ul增加item 12345678$(\"input\").on(\"keypress\",function(e){ if(e.which == 13){ let newevent = $(this).val(); $(this).val(\"\"); //清空输入栏 $(\"ul\").append(\"&lt;li&gt;&lt;span&gt;&lt;i class=\\\"fa fa-trash\\\" aria-hidden=\\\"true\\\"&gt;&lt;/i&gt; &lt;/span&gt;\"+newevent+\"&lt;/li&gt;\"); }}) 如何设计hover滑动淡出淡入特效, 需要结合css和JQuery 12345678910111213span{ transition: 0.3s linear; height: 35px; width: 0; opacity: 0; /*设置能见度,优化显示*/}/*有意思的写法 表示hover的li里面的span*/li:hover span{ width: 35px; opacity: 1.0;}","link":"/2020/07/28/todolist/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/07/05/hello-world/"}],"tags":[{"name":"ES6特性","slug":"ES6特性","link":"/tags/ES6%E7%89%B9%E6%80%A7/"},{"name":"JS基础","slug":"JS基础","link":"/tags/JS%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"闲谈","slug":"闲谈","link":"/categories/%E9%97%B2%E8%B0%88/"},{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"},{"name":"JS","slug":"JS","link":"/categories/JS/"}]}